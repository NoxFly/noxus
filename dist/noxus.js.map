{"version":3,"sources":["../src/index.ts","../src/DI/app-injector.ts","../src/exceptions.ts","../src/router.ts","../src/decorators/guards.decorator.ts","../src/decorators/method.decorator.ts","../src/decorators/module.decorator.ts","../src/utils/logger.ts","../src/DI/injector-explorer.ts","../src/decorators/injectable.decorator.ts","../src/decorators/controller.decorator.ts","../src/decorators/middleware.decorator.ts","../src/utils/radix-tree.ts","../src/app.ts","../src/request.ts","../src/bootstrap.ts"],"sourcesContent":["/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport * from './DI/app-injector';\r\nexport * from './router';\r\nexport * from './app';\r\nexport * from './bootstrap';\r\nexport * from './exceptions';\r\nexport * from './decorators/middleware.decorator';\r\nexport * from './decorators/guards.decorator';\r\nexport * from './decorators/controller.decorator';\r\nexport * from './decorators/injectable.decorator';\r\nexport * from './decorators/method.decorator';\r\nexport * from './decorators/module.decorator';\r\nexport * from './utils/logger';\r\nexport * from './utils/types';\r\nexport * from './request';\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { InternalServerException } from 'src/exceptions';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * Represents a lifetime of a binding in the dependency injection system.\r\n * It can be one of the following:\r\n * - 'singleton': The instance is created once and shared across the application.\r\n * - 'scope': The instance is created once per scope (e.g., per request).\r\n * - 'transient': A new instance is created every time it is requested.\r\n */\r\nexport type Lifetime = 'singleton' | 'scope' | 'transient';\r\n\r\n/**\r\n * Represents a binding in the dependency injection system.\r\n * It contains the lifetime of the binding, the implementation type, and optionally an instance.\r\n */\r\nexport interface IBinding {\r\n    lifetime: Lifetime;\r\n    implementation: Type<unknown>;\r\n    instance?: InstanceType<Type<unknown>>;\r\n}\r\n\r\n/**\r\n * AppInjector is the root dependency injection container.\r\n * It is used to register and resolve dependencies in the application.\r\n * It supports different lifetimes for dependencies:\r\n * This should not be manually instantiated, outside of the framework.\r\n * Use the `RootInjector` instance instead.\r\n */\r\nexport class AppInjector {\r\n    public bindings = new Map<Type<unknown>, IBinding>();\r\n    public singletons = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n    public scoped = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n\r\n    constructor(\r\n        public readonly name: string | null = null,\r\n    ) {}\r\n\r\n    /**\r\n     * Typically used to create a dependency injection scope\r\n     * at the \"scope\" level (i.e., per-request lifetime).\r\n     *\r\n     * SHOULD NOT BE USED by anything else than the framework itself.\r\n     */\r\n    public createScope(): AppInjector {\r\n        const scope = new AppInjector();\r\n        scope.bindings = this.bindings; // pass injectable declarations\r\n        scope.singletons = this.singletons; // share parent's singletons to avoid recreating them\r\n        // do not keep parent's scoped instances\r\n        return scope;\r\n    }\r\n\r\n    /**\r\n     * Called when resolving a dependency,\r\n     * i.e., retrieving the instance of a given class.\r\n     */\r\n    public resolve<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const binding = this.bindings.get(target);\r\n\r\n        if(!binding)\r\n            throw new InternalServerException(\r\n                `Failed to resolve a dependency injection : No binding for type ${target.name}.\\n`\r\n                + `Did you forget to use @Injectable() decorator ?`\r\n            );\r\n\r\n        switch(binding.lifetime) {\r\n            case 'transient':\r\n                return this.instantiate(binding.implementation) as InstanceType<T>;\r\n\r\n            case 'scope': {\r\n                if(this.scoped.has(target)) {\r\n                    return this.scoped.get(target) as InstanceType<T>;\r\n                }\r\n\r\n                const instance = this.instantiate(binding.implementation);\r\n                this.scoped.set(target, instance);\r\n\r\n                return instance as InstanceType<T>;\r\n            }\r\n\r\n            case 'singleton': {\r\n                if(binding.instance === undefined && this.name === 'root') {\r\n                    binding.instance = this.instantiate(binding.implementation);\r\n                    this.singletons.set(target, binding.instance);\r\n                }\r\n\r\n                return binding.instance as InstanceType<T>;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    private instantiate<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];\r\n        const params = paramTypes.map((p: any) => this.resolve(p));\r\n        return new target(...params) as InstanceType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Injects a type from the dependency injection system.\r\n * This function is used to retrieve an instance of a type that has been registered in the dependency injection system.\r\n * It is typically used in the constructor of a class to inject dependencies.\r\n * @param t - The type to inject.\r\n * @returns An instance of the type.\r\n * @throws If the type is not registered in the dependency injection system.\r\n */\r\nexport function inject<T>(t: Type<T>): T {\r\n    return RootInjector.resolve(t);\r\n}\r\n\r\nexport const RootInjector = new AppInjector('root');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport class ResponseException extends Error {\r\n    public readonly status: number = 0;\r\n\r\n    constructor(message?: string);\r\n    constructor(statusCode?: number, message?: string);\r\n    constructor(statusOrMessage?: number | string, message?: string) {\r\n        let statusCode: number | undefined;\r\n        \r\n        if(typeof statusOrMessage === 'number') {\r\n            statusCode = statusOrMessage;\r\n        }\r\n        else if(typeof statusOrMessage === 'string') {\r\n            message = statusOrMessage;\r\n        }\r\n\r\n        super(message ?? \"\");\r\n\r\n        if(statusCode !== undefined) {\r\n            this.status = statusCode;\r\n        }\r\n        \r\n        this.name = this.constructor.name\r\n            .replace(/([A-Z])/g, ' $1');\r\n    }\r\n}\r\n\r\n// 4XX\r\nexport class BadRequestException extends ResponseException { public override readonly status = 400; }\r\nexport class UnauthorizedException extends ResponseException { public override readonly status = 401; }\r\nexport class PaymentRequiredException extends ResponseException { public override readonly status = 402; }\r\nexport class ForbiddenException extends ResponseException { public override readonly status = 403; }\r\nexport class NotFoundException extends ResponseException { public override readonly status = 404; }\r\nexport class MethodNotAllowedException extends ResponseException { public override readonly status = 405; }\r\nexport class NotAcceptableException extends ResponseException { public override readonly status = 406; }\r\nexport class RequestTimeoutException extends ResponseException { public override readonly status = 408; }\r\nexport class ConflictException extends ResponseException { public override readonly status = 409; }\r\nexport class UpgradeRequiredException extends ResponseException { public override readonly status = 426; }\r\nexport class TooManyRequestsException extends ResponseException { public override readonly status = 429; }\r\n// 5XX\r\nexport class InternalServerException extends ResponseException { public override readonly status = 500; }\r\nexport class NotImplementedException extends ResponseException { public override readonly status = 501; }\r\nexport class BadGatewayException extends ResponseException { public override readonly status = 502; }\r\nexport class ServiceUnavailableException extends ResponseException { public override readonly status = 503; }\r\nexport class GatewayTimeoutException extends ResponseException { public override readonly status = 504; }\r\nexport class HttpVersionNotSupportedException extends ResponseException { public override readonly status = 505; }\r\nexport class VariantAlsoNegotiatesException extends ResponseException { public override readonly status = 506; }\r\nexport class InsufficientStorageException extends ResponseException { public override readonly status = 507; }\r\nexport class LoopDetectedException extends ResponseException { public override readonly status = 508; }\r\nexport class NotExtendedException extends ResponseException { public override readonly status = 510; }\r\nexport class NetworkAuthenticationRequiredException extends ResponseException { public override readonly status = 511; }\r\nexport class NetworkConnectTimeoutException extends ResponseException { public override readonly status = 599; }\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { getControllerMetadata } from 'src/decorators/controller.decorator';\r\nimport { getGuardForController, getGuardForControllerAction, IGuard } from 'src/decorators/guards.decorator';\r\nimport { Injectable } from 'src/decorators/injectable.decorator';\r\nimport { getRouteMetadata } from 'src/decorators/method.decorator';\r\nimport { getMiddlewaresForController, getMiddlewaresForControllerAction, IMiddleware, NextFunction } from 'src/decorators/middleware.decorator';\r\nimport { MethodNotAllowedException, NotFoundException, ResponseException, UnauthorizedException } from 'src/exceptions';\r\nimport { IResponse, Request } from 'src/request';\r\nimport { Logger } from 'src/utils/logger';\r\nimport { RadixTree } from 'src/utils/radix-tree';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * IRouteDefinition interface defines the structure of a route in the application.\r\n * It includes the HTTP method, path, controller class, handler method name,\r\n * guards, and middlewares associated with the route.\r\n */\r\nexport interface IRouteDefinition {\r\n    method: string;\r\n    path: string;\r\n    controller: Type<any>;\r\n    handler: string;\r\n    guards: Type<IGuard>[];\r\n    middlewares: Type<IMiddleware>[];\r\n}\r\n\r\n/**\r\n * This type defines a function that represents an action in a controller.\r\n * It takes a Request and an IResponse as parameters and returns a value or a Promise.\r\n */\r\nexport type ControllerAction = (request: Request, response: IResponse) => any;\r\n\r\n\r\n/**\r\n * Router class is responsible for managing the application's routing.\r\n * It registers controllers, handles requests, and manages middlewares and guards.\r\n */\r\n@Injectable('singleton')\r\nexport class Router {\r\n    private readonly routes = new RadixTree<IRouteDefinition>();\r\n    private readonly rootMiddlewares: Type<IMiddleware>[] = [];\r\n\r\n    /**\r\n     * Registers a controller class with the router.\r\n     * This method extracts the route metadata from the controller class and registers it in the routing tree.\r\n     * It also handles the guards and middlewares associated with the controller.\r\n     * @param controllerClass - The controller class to register.\r\n     */\r\n    public registerController(controllerClass: Type<unknown>): Router {\r\n        const controllerMeta = getControllerMetadata(controllerClass);\r\n\r\n        const controllerGuards = getGuardForController(controllerClass.name);\r\n        const controllerMiddlewares = getMiddlewaresForController(controllerClass.name);\r\n\r\n        if(!controllerMeta)\r\n            throw new Error(`Missing @Controller decorator on ${controllerClass.name}`);\r\n\r\n        const routeMetadata = getRouteMetadata(controllerClass);\r\n\r\n        for(const def of routeMetadata) {\r\n            const fullPath = `${controllerMeta.path}/${def.path}`.replace(/\\/+/g, '/');\r\n\r\n            const routeGuards = getGuardForControllerAction(controllerClass.name, def.handler);\r\n            const routeMiddlewares = getMiddlewaresForControllerAction(controllerClass.name, def.handler);\r\n\r\n            const guards = new Set([...controllerGuards, ...routeGuards]);\r\n            const middlewares = new Set([...controllerMiddlewares, ...routeMiddlewares]);\r\n\r\n            const routeDef: IRouteDefinition = {\r\n                method: def.method,\r\n                path: fullPath,\r\n                controller: controllerClass,\r\n                handler: def.handler,\r\n                guards: [...guards],\r\n                middlewares: [...middlewares],\r\n            };\r\n\r\n            this.routes.insert(fullPath + '/' + def.method, routeDef);\r\n\r\n            const hasActionGuards = routeDef.guards.length > 0;\r\n\r\n            const actionGuardsInfo = hasActionGuards\r\n                ? '<' + routeDef.guards.map(g => g.name).join('|') + '>'\r\n                : '';\r\n\r\n            Logger.log(`Mapped {${routeDef.method} /${fullPath}}${actionGuardsInfo} route`);\r\n        }\r\n\r\n        const hasCtrlGuards = controllerMeta.guards.length > 0;\r\n\r\n        const controllerGuardsInfo = hasCtrlGuards\r\n            ? '<' + controllerMeta.guards.map(g => g.name).join('|') + '>'\r\n            : '';\r\n\r\n        Logger.log(`Mapped ${controllerClass.name}${controllerGuardsInfo} controller's routes`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Defines a middleware for the root of the application.\r\n     * This method allows you to register a middleware that will be applied to all requests\r\n     * to the application, regardless of the controller or action.\r\n     * @param middleware - The middleware class to register.\r\n     */\r\n    public defineRootMiddleware(middleware: Type<IMiddleware>): Router {\r\n        this.rootMiddlewares.push(middleware);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Shuts down the message channel for a specific sender ID.\r\n     * This method closes the IPC channel for the specified sender ID and\r\n     * removes it from the messagePorts map.\r\n     * @param channelSenderId - The ID of the sender channel to shut down.\r\n     */\r\n    public async handle(request: Request): Promise<IResponse> {\r\n        Logger.comment(`>     ${request.method} /${request.path}`);\r\n\r\n        const t0 = performance.now();\r\n\r\n        const response: IResponse = {\r\n            requestId: request.id,\r\n            status: 200,\r\n            body: null,\r\n            error: undefined,\r\n        };\r\n\r\n        try {\r\n            const routeDef = this.findRoute(request);\r\n            await this.resolveController(request, response, routeDef);\r\n\r\n            if(response.status > 400) {\r\n                throw new ResponseException(response.status, response.error);\r\n            }\r\n        }\r\n        catch(error: unknown) {\r\n            if(error instanceof ResponseException) {\r\n                response.status = error.status;\r\n                response.error = error.message;\r\n            }\r\n            else if(error instanceof Error) {\r\n                response.status = 500;\r\n                response.error = error.message || 'Internal Server Error';\r\n            }\r\n            else {\r\n                response.status = 500;\r\n                response.error = 'Unknown error occurred';\r\n            }\r\n        }\r\n        finally {\r\n            const t1 = performance.now();\r\n\r\n            const message = `< ${response.status} ${request.method} /${request.path} ${Logger.colors.yellow}${Math.round(t1 - t0)}ms${Logger.colors.initial}`;\r\n\r\n            if(response.status < 400)\r\n                Logger.log(message);\r\n            else if(response.status < 500)\r\n                Logger.warn(message);\r\n            else\r\n                Logger.error(message);\r\n\r\n            if(response.error !== undefined) {\r\n                Logger.error(response.error);\r\n            }\r\n\r\n            return response;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the route definition for a given request.\r\n     * This method searches the routing tree for a matching route based on the request's path and method.\r\n     * If no matching route is found, it throws a NotFoundException.\r\n     * @param request - The Request object containing the method and path to search for.\r\n     * @returns The IRouteDefinition for the matched route.\r\n     */\r\n    private findRoute(request: Request): IRouteDefinition {\r\n        const matchedRoutes = this.routes.search(request.path);\r\n\r\n        if(matchedRoutes?.node === undefined || matchedRoutes.node.children.length === 0) {\r\n            throw new NotFoundException(`No route matches ${request.method} ${request.path}`);\r\n        }\r\n\r\n        const routeDef = matchedRoutes.node.findExactChild(request.method);\r\n\r\n        if(routeDef?.value === undefined) {\r\n            throw new MethodNotAllowedException(`Method Not Allowed for ${request.method} ${request.path}`);\r\n        }\r\n\r\n        return routeDef.value;\r\n    }\r\n\r\n    /**\r\n     * Resolves the controller for a given route definition.\r\n     * This method creates an instance of the controller class and prepares the request parameters.\r\n     * It also runs the request pipeline, which includes executing middlewares and guards.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param routeDef - The IRouteDefinition for the matched route.\r\n     * @return A Promise that resolves when the controller action has been executed.\r\n     * @throws UnauthorizedException if the request is not authorized by the guards.\r\n     */\r\n    private async resolveController(request: Request, response: IResponse, routeDef: IRouteDefinition): Promise<void> {\r\n        const controllerInstance = request.context.resolve(routeDef.controller);\r\n\r\n        Object.assign(request.params, this.extractParams(request.path, routeDef.path));\r\n\r\n        await this.runRequestPipeline(request, response, routeDef, controllerInstance);\r\n    }\r\n\r\n    /**\r\n     * Runs the request pipeline for a given request.\r\n     * This method executes the middlewares and guards associated with the route,\r\n     * and finally calls the controller action.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param routeDef - The IRouteDefinition for the matched route.\r\n     * @param controllerInstance - The instance of the controller class.\r\n     * @return A Promise that resolves when the request pipeline has been executed.\r\n     * @throws ResponseException if the response status is not successful.\r\n     */\r\n    private async runRequestPipeline(request: Request, response: IResponse, routeDef: IRouteDefinition, controllerInstance: any): Promise<void> {\r\n        const middlewares = [...new Set([...this.rootMiddlewares, ...routeDef.middlewares])];\r\n\r\n        const middlewareMaxIndex = middlewares.length - 1;\r\n        const guardsMaxIndex = middlewareMaxIndex + routeDef.guards.length;\r\n\r\n        let index = -1;\r\n\r\n        const dispatch = async (i: number): Promise<void> => {\r\n            if(i <= index)\r\n                throw new Error(\"next() called multiple times\");\r\n\r\n            index = i;\r\n\r\n            // middlewares\r\n            if(i <= middlewareMaxIndex) {\r\n                const nextFn = dispatch.bind(null, i + 1);\r\n                await this.runMiddleware(request, response, nextFn, middlewares[i]!);\r\n\r\n                if(response.status >= 400) {\r\n                    throw new ResponseException(response.status, response.error);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            // guards\r\n            if(i <= guardsMaxIndex) {\r\n                const guardIndex = i - middlewares.length;\r\n                const guardType = routeDef.guards[guardIndex]!;\r\n                await this.runGuard(request, guardType);\r\n                dispatch(i + 1);\r\n                return;\r\n            }\r\n\r\n            // endpoint action\r\n            const action = controllerInstance[routeDef.handler] as ControllerAction;\r\n            response.body = await action.call(controllerInstance, request, response);\r\n\r\n            // avoid parsing error on the renderer if the action just does treatment without returning anything\r\n            if(response.body === undefined) {\r\n                response.body = {};\r\n            }\r\n        };\r\n\r\n        await dispatch(0);\r\n    }\r\n\r\n    /**\r\n     * Runs a middleware function in the request pipeline.\r\n     * This method creates an instance of the middleware and invokes its `invoke` method,\r\n     * passing the request, response, and next function.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param next - The NextFunction to call to continue the middleware chain.\r\n     * @param middlewareType - The type of the middleware to run.\r\n     * @return A Promise that resolves when the middleware has been executed.\r\n     */\r\n    private async runMiddleware(request: Request, response: IResponse, next: NextFunction, middlewareType: Type<IMiddleware>): Promise<void> {\r\n        const middleware = request.context.resolve(middlewareType);\r\n        await middleware.invoke(request, response, next);\r\n    }\r\n\r\n    /**\r\n     * Runs a guard to check if the request is authorized.\r\n     * This method creates an instance of the guard and calls its `canActivate` method.\r\n     * If the guard returns false, it throws an UnauthorizedException.\r\n     * @param request - The Request object containing the request data.\r\n     * @param guardType - The type of the guard to run.\r\n     * @return A Promise that resolves if the guard allows the request, or throws an UnauthorizedException if not.\r\n     * @throws UnauthorizedException if the guard denies access to the request.\r\n     */\r\n    private async runGuard(request: Request, guardType: Type<IGuard>): Promise<void> {\r\n        const guard = request.context.resolve(guardType);\r\n        const allowed = await guard.canActivate(request);\r\n\r\n        if(!allowed)\r\n            throw new UnauthorizedException(`Unauthorized for ${request.method} ${request.path}`);\r\n    }\r\n\r\n    /**\r\n     * Extracts parameters from the actual request path based on the template path.\r\n     * This method splits the actual path and the template path into segments,\r\n     * then maps the segments to parameters based on the template.\r\n     * @param actual - The actual request path.\r\n     * @param template - The template path to extract parameters from.\r\n     * @returns An object containing the extracted parameters.\r\n     */\r\n    private extractParams(actual: string, template: string): Record<string, string> {\r\n        const aParts = actual.split('/');\r\n        const tParts = template.split('/');\r\n        const params: Record<string, string> = {};\r\n\r\n        tParts.forEach((part, i) => {\r\n            if(part.startsWith(':')) {\r\n                params[part.slice(1)] = aParts[i] ?? '';\r\n            }\r\n        });\r\n\r\n        return params;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Request } from 'src/request';\r\nimport { Logger } from 'src/utils/logger';\r\nimport { MaybeAsync, Type } from 'src/utils/types';\r\n\r\n/**\r\n * IGuard interface defines a guard that can be used to protect routes.\r\n * It has a `canActivate` method that takes a request and returns a MaybeAsync boolean.\r\n * The `canActivate` method can return either a value or a Promise.\r\n * Use it on a class that should be registered as a guard in the application.\r\n * Guards can be used to protect routes or controller actions.\r\n * For example, you can use guards to check if the user is authenticated or has the right permissions.\r\n * You can use the `Authorize` decorator to register guards for a controller or a controller action.\r\n * @see Authorize\r\n */\r\nexport interface IGuard {\r\n    canActivate(request: Request): MaybeAsync<boolean>;\r\n}\r\n\r\n/**\r\n * Can be used to protect the routes of a controller.\r\n * Can be used on a controller class or on a controller method.\r\n */\r\nexport function Authorize(...guardClasses: Type<IGuard>[]): MethodDecorator & ClassDecorator {\r\n    return (target: Function | object, propertyKey?: string | symbol) => {\r\n        let key: string;\r\n\r\n        // Method decorator\r\n        if(propertyKey) {\r\n            const ctrlName = target.constructor.name;\r\n            const actionName = propertyKey as string;\r\n            key = `${ctrlName}.${actionName}`;\r\n        }\r\n        // Class decorator\r\n        else {\r\n            const ctrlName = (target as Type<unknown>).name;\r\n            key = `${ctrlName}`;\r\n        }\r\n\r\n        if(authorizations.has(key)) {\r\n            throw new Error(`Guard(s) already registered for ${key}`);\r\n        }\r\n\r\n        authorizations.set(key, guardClasses);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the guards for a controller or a controller action.\r\n * @param controllerName The name of the controller to get the guards for.\r\n * @returns An array of guards for the controller.\r\n */\r\nexport function getGuardForController(controllerName: string): Type<IGuard>[] {\r\n    const key = `${controllerName}`;\r\n    return authorizations.get(key) ?? [];\r\n}\r\n\r\n/**\r\n * Gets the guards for a controller action.\r\n * @param controllerName The name of the controller to get the guards for.\r\n * @param actionName The name of the action to get the guards for.\r\n * @returns An array of guards for the controller action.\r\n */\r\nexport function getGuardForControllerAction(controllerName: string, actionName: string): Type<IGuard>[] {\r\n    const key = `${controllerName}.${actionName}`;\r\n    return authorizations.get(key) ?? [];\r\n}\r\n\r\nconst authorizations = new Map<string, Type<IGuard>[]>();\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getGuardForControllerAction, IGuard } from \"src/decorators/guards.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * IRouteMetadata interface defines the metadata for a route.\r\n * It includes the HTTP method, path, handler name, and guards associated with the route.\r\n * This metadata is used to register the route in the application.\r\n * This is the configuration that waits a route's decorator.\r\n */\r\nexport interface IRouteMetadata {\r\n    method: HttpMethod;\r\n    path: string;\r\n    handler: string;\r\n    guards: Type<IGuard>[];\r\n}\r\n\r\n/**\r\n * The different HTTP methods that can be used in the application.\r\n */\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\r\n\r\n/**\r\n * The configuration that waits a route's decorator.\r\n * It contains the HTTP method, path, handler, and guards for the route.\r\n * @param verb The HTTP method for the route.\r\n * @returns A method decorator that registers the route with the specified HTTP method.\r\n */\r\nfunction createRouteDecorator(verb: HttpMethod): (path: string) => MethodDecorator {\r\n    return (path: string): MethodDecorator => {\r\n        return (target, propertyKey) => {\r\n            const existingRoutes: IRouteMetadata[] = Reflect.getMetadata(ROUTE_METADATA_KEY, target.constructor) || [];\r\n\r\n            const metadata: IRouteMetadata = {\r\n                method: verb,\r\n                path: path.trim().replace(/^\\/|\\/$/g, ''),\r\n                handler: propertyKey as string,\r\n                guards: getGuardForControllerAction((target.constructor as any).__controllerName, propertyKey as string),\r\n            };\r\n\r\n            existingRoutes.push(metadata);\r\n\r\n            Reflect.defineMetadata(ROUTE_METADATA_KEY, existingRoutes, target.constructor);\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the route metadata for a given target class.\r\n * This metadata includes the HTTP method, path, handler, and guards defined by the route decorators.\r\n * @see Get\r\n * @see Post\r\n * @see Put\r\n * @see Patch\r\n * @see Delete\r\n * @param target The target class to get the route metadata from.\r\n * @returns An array of route metadata if it exists, otherwise an empty array.\r\n */\r\nexport function getRouteMetadata(target: Type<unknown>): IRouteMetadata[] {\r\n    return Reflect.getMetadata(ROUTE_METADATA_KEY, target) || [];\r\n}\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the GET method.\r\n */\r\nexport const Get = createRouteDecorator('GET');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the POST method.\r\n */\r\nexport const Post = createRouteDecorator('POST');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the PUT method.\r\n */\r\nexport const Put = createRouteDecorator('PUT');\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the PATCH method.\r\n */\r\nexport const Patch = createRouteDecorator('PATCH');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the DELETE method.\r\n */\r\nexport const Delete = createRouteDecorator('DELETE');\r\n\r\nexport const ROUTE_METADATA_KEY = Symbol('ROUTE_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { CONTROLLER_METADATA_KEY } from \"src/decorators/controller.decorator\";\r\nimport { Injectable, INJECTABLE_METADATA_KEY } from \"src/decorators/injectable.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\nexport interface IModuleMetadata {\r\n    imports?: Type<unknown>[];\r\n    exports?: Type<unknown>[];\r\n    providers?: Type<unknown>[];\r\n    controllers?: Type<unknown>[];\r\n}\r\n\r\n/**\r\n * Module decorator is used to define a module in the application.\r\n * It is a kind of node in the routing tree, that can contains controllers, services, and other modules.\r\n *\r\n * @param metadata - The metadata for the module.\r\n */\r\nexport function Module(metadata: IModuleMetadata): ClassDecorator {\r\n    return (target: Function) => {\r\n        // Validate imports and exports: must be decorated with @Module\r\n        const checkModule = (arr?: Type<unknown>[], arrName?: string): void => {\r\n            if(!arr)\r\n                return;\r\n\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(MODULE_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in ${arrName} must be decorated with @Module`);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Validate providers: must be decorated with @Injectable\r\n        const checkInjectable = (arr?: Type<unknown>[]): void => {\r\n            if(!arr)\r\n                return;\r\n\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(INJECTABLE_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in providers must be decorated with @Injectable`);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Validate controllers: must be decorated with @Controller\r\n        const checkController = (arr?: Type<unknown>[]): void => {\r\n            if(!arr) return;\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(CONTROLLER_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in controllers must be decorated with @Controller`);\r\n                }\r\n            }\r\n        };\r\n\r\n        checkModule(metadata.imports, 'imports');\r\n        checkModule(metadata.exports, 'exports');\r\n        checkInjectable(metadata.providers);\r\n        checkController(metadata.controllers);\r\n\r\n        Reflect.defineMetadata(MODULE_METADATA_KEY, metadata, target);\r\n\r\n        Injectable('singleton')(target);\r\n    };\r\n}\r\n\r\nexport function getModuleMetadata(target: Function): IModuleMetadata | undefined {\r\n    return Reflect.getMetadata(MODULE_METADATA_KEY, target);\r\n}\r\n\r\nexport const MODULE_METADATA_KEY = Symbol('MODULE_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Logger is a utility class for logging messages to the console.\r\n */\r\nexport type LogLevel = 'log' | 'info' | 'warn' | 'error' | 'debug' | 'comment';\r\n\r\n/**\r\n * Returns a formatted timestamp for logging.\r\n */\r\nfunction getPrettyTimestamp(): string {\r\n    const now = new Date();\r\n    return `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear()}`\r\n        + ` ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;\r\n}\r\n\r\n/**\r\n * Generates a log prefix for the console output.\r\n * @param callee - The name of the function or class that is logging the message.\r\n * @param messageType - The type of message being logged (e.g., 'log', 'info', 'warn', 'error', 'debug').\r\n * @param color - The color to use for the log message.\r\n * @returns A formatted string that includes the timestamp, process ID, message type, and callee name.\r\n */\r\nfunction getLogPrefix(callee: string, messageType: string, color: string): string {\r\n    const timestamp = getPrettyTimestamp();\r\n\r\n    const spaces = ' '.repeat(10 - messageType.length);\r\n\r\n    return `${color}[APP] ${process.pid} - ${Logger.colors.initial}`\r\n        + `${timestamp}${spaces}`\r\n        + `${color}${messageType.toUpperCase()}${Logger.colors.initial} `\r\n        + `${Logger.colors.yellow}[${callee}]${Logger.colors.initial}`;\r\n}\r\n\r\n/**\r\n * Formats an object into a string representation for logging.\r\n * It converts the object to JSON and adds indentation for readability.\r\n * @param prefix - The prefix to use for the formatted object.\r\n * @param arg - The object to format.\r\n * @returns A formatted string representation of the object, with each line prefixed by the specified prefix.\r\n */\r\nfunction formatObject(prefix: string, arg: object): string {\r\n    const json = JSON.stringify(arg, null, 2);\r\n\r\n    const prefixedJson = json\r\n        .split('\\n')\r\n        .map((line, idx) => idx === 0 ? `${Logger.colors.darkGrey}${line}` : `${prefix} ${Logger.colors.grey}${line}`)\r\n        .join('\\n') + Logger.colors.initial;\r\n\r\n    return prefixedJson;\r\n}\r\n\r\n/**\r\n * Formats the arguments for logging.\r\n * It colors strings and formats objects with indentation.\r\n * This function is used to prepare the arguments for console output.\r\n * @param prefix - The prefix to use for the formatted arguments.\r\n * @param args - The arguments to format.\r\n * @param color - The color to use for the formatted arguments.\r\n * @returns An array of formatted arguments, where strings are colored and objects are formatted with indentation.\r\n */\r\nfunction formattedArgs(prefix: string, args: any[], color: string): any[] {\r\n    return args.map(arg => {\r\n        if(typeof arg === 'string') {\r\n            return `${color}${arg}${Logger.colors.initial}`;\r\n        }\r\n\r\n        else if(typeof arg === 'object') {\r\n            return formatObject(prefix, arg);\r\n        }\r\n\r\n        return arg;\r\n    });\r\n}\r\n\r\n/**\r\n * Gets the name of the caller function or class from the stack trace.\r\n * This function is used to determine the context of the log message.\r\n * @returns The name of the caller function or class.\r\n */\r\nfunction getCallee(): string {\r\n    const stack = new Error().stack?.split('\\n') ?? [];\r\n    const caller = stack[3]\r\n        ?.trim()\r\n        .match(/at (.+?)(?:\\..+)? .+$/)\r\n        ?.[1]\r\n        ?.replace('Object', '')\r\n        .replace(/^_/, '')\r\n        || \"App\";\r\n    return caller;\r\n}\r\n\r\n/**\r\n * Checks if the current log level allows logging the specified level.\r\n * This function compares the current log level with the specified level to determine if logging should occur.\r\n * @param level - The log level to check.\r\n * @returns A boolean indicating whether the log level is enabled.\r\n */\r\nfunction canLog(level: LogLevel): boolean {\r\n    return logLevelRank[level] >= logLevelRank[logLevel];\r\n}\r\n\r\n\r\nlet logLevel: LogLevel = 'debug';\r\n\r\nconst logLevelRank: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    comment: 1,\r\n    log: 2,\r\n    info: 3,\r\n    warn: 4,\r\n    error: 5,\r\n};\r\n\r\nexport namespace Logger {\r\n\r\n    /**\r\n     * Sets the log level for the logger.\r\n     * This function allows you to change the log level dynamically at runtime.\r\n     * This won't affect the startup logs.\r\n     * @param level Sets the log level for the logger.\r\n     */\r\n    export function setLogLevel(level: LogLevel): void {\r\n        logLevel = level;\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level LOG.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function log(...args: any[]): void {\r\n        if(!canLog('log'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"log\", colors.green);\r\n        console.log(prefix, ...formattedArgs(prefix, args, colors.green));\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level INFO.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function info(...args: any[]): void {\r\n        if(!canLog('info'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"info\", colors.blue);\r\n        console.info(prefix, ...formattedArgs(prefix, args, colors.blue));\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level WARN.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function warn(...args: any[]): void {\r\n        if(!canLog('warn'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"warn\", colors.brown);\r\n        console.warn(prefix, ...formattedArgs(prefix, args, colors.brown));\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level ERROR.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function error(...args: any[]): void {\r\n        if(!canLog('error'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"error\", colors.red);\r\n        console.error(prefix, ...formattedArgs(prefix, args, colors.red));\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level DEBUG.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function debug(...args: any[]): void {\r\n        if(!canLog('debug'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"debug\", colors.purple);\r\n        console.debug(prefix, ...formattedArgs(prefix, args, colors.purple));\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level COMMENT.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function comment(...args: any[]): void {\r\n        if(!canLog('comment'))\r\n            return;\r\n\r\n        const callee = getCallee();\r\n        const prefix = getLogPrefix(callee, \"comment\", colors.grey);\r\n        console.debug(prefix, ...formattedArgs(prefix, args, colors.grey));\r\n    }\r\n\r\n\r\n    export const colors = {\r\n        black: '\\x1b[0;30m',\r\n        grey: '\\x1b[0;37m',\r\n        red: '\\x1b[0;31m',\r\n        green: '\\x1b[0;32m',\r\n        brown: '\\x1b[0;33m',\r\n        blue: '\\x1b[0;34m',\r\n        purple: '\\x1b[0;35m',\r\n\r\n        darkGrey: '\\x1b[1;30m',\r\n        lightRed: '\\x1b[1;31m',\r\n        lightGreen: '\\x1b[1;32m',\r\n        yellow: '\\x1b[1;33m',\r\n        lightBlue: '\\x1b[1;34m',\r\n        magenta: '\\x1b[1;35m',\r\n        cyan: '\\x1b[1;36m',\r\n        white: '\\x1b[1;37m',\r\n\r\n        initial: '\\x1b[0m'\r\n    };\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getControllerMetadata } from \"src/decorators/controller.decorator\";\r\nimport { getInjectableMetadata } from \"src/decorators/injectable.decorator\";\r\nimport { getRouteMetadata } from \"src/decorators/method.decorator\";\r\nimport { getModuleMetadata } from \"src/decorators/module.decorator\";\r\nimport { Lifetime, RootInjector } from \"src/DI/app-injector\";\r\nimport { Router } from \"src/router\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * InjectorExplorer is a utility class that explores the dependency injection system at the startup.\r\n */\r\nexport class InjectorExplorer {\r\n    /**\r\n     * Registers the class as injectable.\r\n     * When a class is instantiated, if it has dependencies and those dependencies\r\n     * are listed using this method, they will be injected into the class constructor.\r\n     */\r\n    public static register(target: Type<unknown>, lifetime: Lifetime): typeof RootInjector {\r\n        if(RootInjector.bindings.has(target)) // already registered\r\n            return RootInjector;\r\n\r\n        RootInjector.bindings.set(target, {\r\n            implementation: target,\r\n            lifetime\r\n        });\r\n\r\n        if(lifetime === 'singleton') {\r\n            RootInjector.resolve(target);\r\n        }\r\n\r\n        if(getModuleMetadata(target)) {\r\n            Logger.log(`${target.name} dependencies initialized`);\r\n            return RootInjector;\r\n        }\r\n\r\n        const controllerMeta = getControllerMetadata(target);\r\n\r\n        if(controllerMeta) {\r\n            const router = RootInjector.resolve(Router);\r\n            router?.registerController(target);\r\n            return RootInjector;\r\n        }\r\n\r\n        const routeMeta = getRouteMetadata(target);\r\n\r\n        if(routeMeta) {\r\n            return RootInjector;\r\n        }\r\n\r\n        if(getInjectableMetadata(target)) {\r\n            Logger.log(`Registered ${target.name} as ${lifetime}`);\r\n            return RootInjector;\r\n        }\r\n\r\n        return RootInjector;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Lifetime } from \"src/DI/app-injector\";\r\nimport { InjectorExplorer } from \"src/DI/injector-explorer\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * The Injectable decorator marks a class as injectable.\r\n * It allows the class to be registered in the dependency injection system.\r\n * A class decorated with @Injectable can be injected into other classes\r\n * either from the constructor of the class that needs it of from the `inject` function.\r\n * @param lifetime - The lifetime of the injectable. Can be 'singleton', 'scope', or 'transient'.\r\n */\r\nexport function Injectable(lifetime: Lifetime = 'scope'): ClassDecorator {\r\n    return (target) => {\r\n        if(typeof target !== 'function' || !target.prototype) {\r\n            throw new Error(`@Injectable can only be used on classes, not on ${typeof target}`);\r\n        }\r\n\r\n        Reflect.defineMetadata(INJECTABLE_METADATA_KEY, lifetime, target);\r\n        InjectorExplorer.register(target as unknown as Type<any>, lifetime);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the injectable metadata for a given target class.\r\n * This metadata includes the lifetime of the injectable defined by the @Injectable decorator.\r\n * @param target - The target class to get the injectable metadata from.\r\n * @returns The lifetime of the injectable if it exists, otherwise undefined.\r\n */\r\nexport function getInjectableMetadata(target: Type<unknown>): Lifetime | undefined {\r\n    return Reflect.getMetadata(INJECTABLE_METADATA_KEY, target);\r\n}\r\n\r\nexport const INJECTABLE_METADATA_KEY = Symbol('INJECTABLE_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getGuardForController, IGuard } from \"src/decorators/guards.decorator\";\r\nimport { Injectable } from \"src/decorators/injectable.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * The configuration that waits a controller's decorator.\r\n */\r\nexport interface IControllerMetadata {\r\n    path: string;\r\n    guards: Type<IGuard>[];\r\n}\r\n\r\n/**\r\n * Controller decorator is used to define a controller in the application.\r\n * It is a kind of node in the routing tree, that can contains routes and middlewares.\r\n *\r\n * @param path - The path for the controller.\r\n */\r\nexport function Controller(path: string): ClassDecorator {\r\n    return (target) => {\r\n        const data: IControllerMetadata = {\r\n            path,\r\n            guards: getGuardForController(target.name)\r\n        };\r\n\r\n        Reflect.defineMetadata(CONTROLLER_METADATA_KEY, data, target);\r\n        Injectable('scope')(target);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the controller metadata for a given target class.\r\n * This metadata includes the path and guards defined by the @Controller decorator.\r\n * @param target - The target class to get the controller metadata from.\r\n * @returns The controller metadata if it exists, otherwise undefined.\r\n */\r\nexport function getControllerMetadata(target: Type<unknown>): IControllerMetadata | undefined {\r\n    return Reflect.getMetadata(CONTROLLER_METADATA_KEY, target);\r\n}\r\n\r\nexport const CONTROLLER_METADATA_KEY = Symbol('CONTROLLER_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { IResponse, Request } from \"src/request\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { MaybeAsync, Type } from \"src/utils/types\";\r\n\r\n/**\r\n * NextFunction is a function that is called to continue the middleware chain.\r\n * It returns an Promise that emits when the next middleware is done.\r\n */\r\nexport type NextFunction = () => Promise<void>;\r\n\r\n/**\r\n * IMiddleware interface defines a middleware that can be used in the application.\r\n * It has an `invoke` method that takes a request, a response, and a next function.\r\n * The `invoke` method can return a MaybeAsync, which means it can return either a value or a Promise.\r\n *\r\n * Use it on a class that should be registered as a middleware in the application.\r\n */\r\nexport interface IMiddleware {\r\n    invoke(request: Request, response: IResponse, next: NextFunction): MaybeAsync<void>;\r\n}\r\n\r\n/**\r\n * UseMiddlewares decorator can be used to register middlewares for a controller or a controller action.\r\n *\r\n * @param mdlw - The middlewares list to register for the controller or the controller action.\r\n */\r\nexport function UseMiddlewares(mdlw: Type<IMiddleware>[]): ClassDecorator & MethodDecorator {\r\n    return (target: Function | object, propertyKey?: string | symbol) => {\r\n        let key: string;\r\n\r\n        // Method decorator\r\n        if(propertyKey) {\r\n            const ctrlName = target.constructor.name;\r\n            const actionName = propertyKey as string;\r\n            key = `${ctrlName}.${actionName}`;\r\n        }\r\n        // Class decorator\r\n        else {\r\n            const ctrlName = (target as Type<unknown>).name;\r\n            key = `${ctrlName}`;\r\n        }\r\n\r\n        if(middlewares.has(key)) {\r\n            throw new Error(`Middlewares(s) already registered for ${key}`);\r\n        }\r\n\r\n        middlewares.set(key, mdlw);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the middlewares for a controller or a controller action.\r\n * This function retrieves the middlewares registered with the UseMiddlewares decorator.\r\n * It returns an array of middleware classes that can be used to process requests for the specified controller.\r\n * @param controllerName The name of the controller to get the middlewares for.\r\n * @returns An array of middlewares for the controller.\r\n */\r\nexport function getMiddlewaresForController(controllerName: string): Type<IMiddleware>[] {\r\n    const key = `${controllerName}`;\r\n    return middlewares.get(key) ?? [];\r\n}\r\n\r\n/**\r\n * Gets the middlewares for a controller action.\r\n * This function retrieves the middlewares registered with the UseMiddlewares decorator for a specific action in a controller.\r\n * It returns an array of middleware classes that can be used to process requests for the specified controller action.\r\n * @param controllerName The name of the controller to get the middlewares for.\r\n * @param actionName The name of the action to get the middlewares for.\r\n * @returns An array of middlewares for the controller action.\r\n */\r\nexport function getMiddlewaresForControllerAction(controllerName: string, actionName: string): Type<IMiddleware>[] {\r\n    const key = `${controllerName}.${actionName}`;\r\n    return middlewares.get(key) ?? [];\r\n}\r\n\r\nconst middlewares = new Map<string, Type<IMiddleware>[]>();\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n *\r\n */\r\ntype Params = Record<string, string>;\r\n\r\n/**\r\n * Represents a search result in the Radix Tree.\r\n */\r\ninterface ISearchResult<T> {\r\n    node: RadixNode<T>;\r\n    params: Params;\r\n}\r\n\r\n/**\r\n * Represents a node in the Radix Tree.\r\n * The represents a path segment\r\n */\r\nclass RadixNode<T> {\r\n    public segment: string;\r\n    public children: RadixNode<T>[] = [];\r\n    public value?: T;\r\n    public isParam: boolean;\r\n    public paramName?: string;\r\n\r\n    /**\r\n     * Creates a new RadixNode.\r\n     * @param segment - The segment of the path this node represents.\r\n     */\r\n    constructor(segment: string) {\r\n        this.segment = segment;\r\n        this.isParam = segment.startsWith(\":\");\r\n\r\n        if(this.isParam) {\r\n            this.paramName = segment.slice(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Matches a child node against a given segment.\r\n     * This method checks if the segment matches any of the children nodes.\r\n     * @param segment - The segment to match against the children of this node.\r\n     * @returns A child node that matches the segment, or undefined if no match is found.\r\n     */\r\n    public matchChild(segment: string): RadixNode<T> | undefined {\r\n        for(const child of this.children) {\r\n            if(child.isParam || segment.startsWith(child.segment))\r\n                return child; // param match\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Finds a child node that matches the segment exactly.\r\n     * This method checks if there is a child node that matches the segment exactly.\r\n     * @param segment - The segment to find an exact match for among the children of this node.\r\n     * @returns A child node that matches the segment exactly, or undefined if no match is found.\r\n     */\r\n    public findExactChild(segment: string): RadixNode<T> | undefined {\r\n        return this.children.find(c => c.segment === segment);\r\n    }\r\n\r\n    /**\r\n     * Adds a child node to this node's children.\r\n     * This method adds a new child node to the list of children for this node.\r\n     * @param node - The child node to add to this node's children.\r\n     */\r\n    public addChild(node: RadixNode<T>): void {\r\n        this.children.push(node);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport class RadixTree<T> {\r\n    private readonly root = new RadixNode<T>(\"\");\r\n\r\n    /**\r\n     * Inserts a path and its associated value into the Radix Tree.\r\n     * This method normalizes the path and inserts it into the tree, associating it with\r\n     * @param path - The path to insert into the tree.\r\n     * @param value - The value to associate with the path.\r\n     */\r\n    public insert(path: string, value: T): void {\r\n        const segments = this.normalize(path);\r\n        this.insertRecursive(this.root, segments, value);\r\n    }\r\n\r\n    /**\r\n     * Recursively inserts a path into the Radix Tree.\r\n     * This method traverses the tree and inserts the segments of the path, creating new nodes\r\n     * @param node - The node to start inserting from.\r\n     * @param segments - The segments of the path to insert.\r\n     * @param value - The value to associate with the path.\r\n     */\r\n    private insertRecursive(node: RadixNode<T>, segments: string[], value: T): void {\r\n        if(segments.length === 0) {\r\n            node.value = value;\r\n            return;\r\n        }\r\n\r\n        const segment = segments[0] ?? \"\";\r\n\r\n        let child = node.children.find(c =>\r\n            c.isParam === segment.startsWith(\":\") &&\r\n            (c.isParam || c.segment === segment)\r\n        );\r\n\r\n        if(!child) {\r\n            child = new RadixNode<T>(segment);\r\n            node.addChild(child);\r\n        }\r\n\r\n        this.insertRecursive(child, segments.slice(1), value);\r\n    }\r\n\r\n    /**\r\n     * Searches for a path in the Radix Tree.\r\n     * This method normalizes the path and searches for it in the tree, returning the node\r\n     * @param path - The path to search for in the Radix Tree.\r\n     * @returns An ISearchResult containing the node and parameters if a match is found, otherwise undefined.\r\n     */\r\n    public search(path: string): ISearchResult<T> | undefined {\r\n        const segments = this.normalize(path);\r\n        return this.searchRecursive(this.root, segments, {});\r\n    }\r\n\r\n    /**\r\n     * Recursively searches for a path in the Radix Tree.\r\n     * This method traverses the tree and searches for the segments of the path, collecting parameters\r\n     * @param node - The node to start searching from.\r\n     * @param segments - The segments of the path to search for.\r\n     * @param params - The parameters collected during the search.\r\n     * @returns An ISearchResult containing the node and parameters if a match is found, otherwise undefined.\r\n     */\r\n    private searchRecursive(node: RadixNode<T>, segments: string[], params: Params): ISearchResult<T> | undefined {\r\n        if(segments.length === 0) {\r\n            if(node.value !== undefined) {\r\n                return {\r\n                    node: node,\r\n                    params\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        const [segment, ...rest] = segments;\r\n\r\n        for(const child of node.children) {\r\n            if(child.isParam) {\r\n                const paramName = child.paramName!;\r\n\r\n                const childParams: Params = {\r\n                    ...params,\r\n                    [paramName]: segment ?? \"\",\r\n                };\r\n\r\n                if(rest.length === 0) {\r\n                    return {\r\n                        node: child,\r\n                        params: childParams\r\n                    };\r\n                }\r\n\r\n                const result = this.searchRecursive(child, rest, childParams);\r\n\r\n                if(result)\r\n                    return result;\r\n            }\r\n            else if(segment === child.segment) {\r\n                if(rest.length === 0) {\r\n                    return {\r\n                        node: child,\r\n                        params\r\n                    };\r\n                }\r\n\r\n                const result = this.searchRecursive(child, rest, params);\r\n\r\n                if(result)\r\n                    return result;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Normalizes a path into an array of segments.\r\n     * This method removes leading and trailing slashes, splits the path by slashes, and\r\n     * @param path - The path to normalize.\r\n     * @returns An array of normalized path segments.\r\n     */\r\n    private normalize(path: string): string[] {\r\n        const segments = path\r\n            .replace(/^\\/+|\\/+$/g, \"\")\r\n            .split(\"/\")\r\n            .filter(Boolean);\r\n\r\n        return ['', ...segments];\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { app, BrowserWindow, ipcMain, MessageChannelMain } from \"electron/main\";\r\nimport { Injectable } from \"src/decorators/injectable.decorator\";\r\nimport { IMiddleware } from \"src/decorators/middleware.decorator\";\r\nimport { inject } from \"src/DI/app-injector\";\r\nimport { IRequest, IResponse, Request } from \"src/request\";\r\nimport { Router } from \"src/router\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * The application service should implement this interface, as\r\n * the NoxApp class instance will use it to notify the given service\r\n * about application lifecycle events.\r\n */\r\nexport interface IApp {\r\n    dispose(): Promise<void>;\r\n    onReady(): Promise<void>;\r\n    onActivated(): Promise<void>;\r\n}\r\n\r\n/**\r\n * NoxApp is the main application class that manages the application lifecycle,\r\n * handles IPC communication, and integrates with the Router.\r\n */\r\n@Injectable('singleton')\r\nexport class NoxApp {\r\n    private readonly messagePorts = new Map<number, Electron.MessageChannelMain>();\r\n    private app: IApp | undefined;\r\n\r\n    constructor(\r\n        private readonly router: Router,\r\n    ) {}\r\n\r\n    /**\r\n     * Initializes the NoxApp instance.\r\n     * This method sets up the IPC communication, registers event listeners,\r\n     * and prepares the application for use.\r\n     */\r\n    public async init(): Promise<NoxApp> {\r\n        ipcMain.on('gimme-my-port', this.giveTheRendererAPort.bind(this));\r\n\r\n        app.once('activate', this.onAppActivated.bind(this));\r\n        app.once('window-all-closed', this.onAllWindowsClosed.bind(this));\r\n\r\n        console.log(''); // create a new line in the console to separate setup logs from the future logs\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Handles the request from the renderer process.\r\n     * This method creates a Request object from the IPC event data,\r\n     * processes it through the Router, and sends the response back\r\n     * to the renderer process using the MessageChannel.\r\n     */\r\n    private giveTheRendererAPort(event: Electron.IpcMainInvokeEvent): void {\r\n        const senderId = event.sender.id;\r\n\r\n        if(this.messagePorts.has(senderId)) {\r\n            this.shutdownChannel(senderId);\r\n        }\r\n\r\n        const channel = new MessageChannelMain();\r\n        this.messagePorts.set(senderId, channel);\r\n\r\n        channel.port1.on('message', this.onRendererMessage.bind(this));\r\n        channel.port1.start();\r\n\r\n        event.sender.postMessage('port', { senderId }, [channel.port2]);\r\n    }\r\n\r\n    /**\r\n     * Electron specific message handling.\r\n     * Replaces HTTP calls by using Electron's IPC mechanism.\r\n     */\r\n    private async onRendererMessage(event: Electron.MessageEvent): Promise<void> {\r\n        const { senderId, requestId, path, method, body }: IRequest = event.data;\r\n\r\n        const channel = this.messagePorts.get(senderId);\r\n\r\n        if(!channel) {\r\n            Logger.error(`No message channel found for sender ID: ${senderId}`);\r\n            return;\r\n        }\r\n        try {\r\n            const request = new Request(event, requestId, method, path, body);\r\n            const response = await this.router.handle(request);\r\n            channel.port1.postMessage(response);\r\n        }\r\n        catch(err: any) {\r\n            const response: IResponse = {\r\n                requestId,\r\n                status: 500,\r\n                body: null,\r\n                error: err.message || 'Internal Server Error',\r\n            };\r\n\r\n            channel.port1.postMessage(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * MacOS specific behavior.\r\n     */\r\n    private onAppActivated(): void {\r\n        if(process.platform === 'darwin' && BrowserWindow.getAllWindows().length === 0) {\r\n            this.app?.onActivated();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shuts down the message channel for a specific sender ID.\r\n     * This method closes the IPC channel for the specified sender ID and\r\n     * removes it from the messagePorts map.\r\n     * @param channelSenderId - The ID of the sender channel to shut down.\r\n     * @param remove - Whether to remove the channel from the messagePorts map.\r\n     */\r\n    private shutdownChannel(channelSenderId: number): void {\r\n        const channel = this.messagePorts.get(channelSenderId);\r\n\r\n        if(!channel) {\r\n            Logger.warn(`No message channel found for sender ID: ${channelSenderId}`);\r\n            return;\r\n        }\r\n\r\n        channel.port1.off('message', this.onRendererMessage.bind(this));\r\n        channel.port1.close();\r\n        channel.port2.close();\r\n\r\n        this.messagePorts.delete(channelSenderId);\r\n    }\r\n\r\n    /**\r\n     * Handles the application shutdown process.\r\n     * This method is called when all windows are closed, and it cleans up the message channels\r\n     */\r\n    private async onAllWindowsClosed(): Promise<void> {\r\n        this.messagePorts.forEach((channel, senderId) => {\r\n            this.shutdownChannel(senderId);\r\n        });\r\n\r\n        this.messagePorts.clear();\r\n\r\n        Logger.info('All windows closed, shutting down application...');\r\n        await this.app?.dispose();\r\n\r\n        if(process.platform !== 'darwin') {\r\n            app.quit();\r\n        }\r\n    }\r\n\r\n\r\n    // ---\r\n\r\n    /**\r\n     * Configures the NoxApp instance with the provided application class.\r\n     * This method allows you to set the application class that will handle lifecycle events.\r\n     * @param app - The application class to configure.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public configure(app: Type<IApp>): NoxApp {\r\n        this.app = inject(app);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers a middleware for the root of the application.\r\n     * This method allows you to define a middleware that will be applied to all requests\r\n     * @param middleware - The middleware class to register.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public use(middleware: Type<IMiddleware>): NoxApp {\r\n        this.router.defineRootMiddleware(middleware);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Should be called after the bootstrapApplication function is called.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public start(): NoxApp {\r\n        this.app?.onReady();\r\n        return this;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { HttpMethod } from 'src/decorators/method.decorator';\r\nimport { AppInjector, RootInjector } from 'src/DI/app-injector';\r\n\r\n/**\r\n * The Request class represents an HTTP request in the Noxus framework.\r\n * It encapsulates the request data, including the event, ID, method, path, and body.\r\n * It also provides a context for dependency injection through the AppInjector.\r\n */\r\nexport class Request {\r\n    public readonly context: AppInjector = RootInjector.createScope();\r\n\r\n    public readonly params: Record<string, string> = {};\r\n\r\n    constructor(\r\n        public readonly event: Electron.MessageEvent,\r\n        public readonly id: string,\r\n        public readonly method: HttpMethod,\r\n        public readonly path: string,\r\n        public readonly body: any,\r\n    ) {\r\n        this.path = path.replace(/^\\/|\\/$/g, '');\r\n    }\r\n}\r\n\r\n/**\r\n * The IRequest interface defines the structure of a request object.\r\n * It includes properties for the sender ID, request ID, path, method, and an optional body.\r\n * This interface is used to standardize the request data across the application.\r\n */\r\nexport interface IRequest<T = any> {\r\n    senderId: number;\r\n    requestId: string;\r\n    path: string;\r\n    method: HttpMethod;\r\n    body?: T;\r\n}\r\n\r\n/**\r\n * Creates a Request object from the IPC event data.\r\n * This function extracts the necessary information from the IPC event and constructs a Request instance.\r\n */\r\nexport interface IResponse<T = any> {\r\n    requestId: string;\r\n    status: number;\r\n    body?: T;\r\n    error?: string;\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { app } from \"electron/main\";\r\nimport { NoxApp } from \"src/app\";\r\nimport { getModuleMetadata } from \"src/decorators/module.decorator\";\r\nimport { inject } from \"src/DI/app-injector\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * Bootstraps the Noxus application.\r\n * This function initializes the application by creating an instance of NoxApp,\r\n * registering the root module, and starting the application.\r\n * @param rootModule - The root module of the application, decorated with @Module.\r\n * @return A promise that resolves to the NoxApp instance.\r\n * @throws Error if the root module is not decorated with @Module, or if the electron process could not start.\r\n */\r\nexport async function bootstrapApplication(rootModule: Type<any>): Promise<NoxApp> {\r\n    if(!getModuleMetadata(rootModule)) {\r\n        throw new Error(`Root module must be decorated with @Module`);\r\n    }\r\n\r\n    await app.whenReady();\r\n\r\n    const noxApp = inject(NoxApp);\r\n\r\n    await noxApp.init();\r\n\r\n    return noxApp;\r\n}\r\n\r\n"],"mappings":"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","names":["ResponseException","Error","statusOrMessage","message","statusCode","status","undefined","name","replace","BadRequestException","UnauthorizedException","PaymentRequiredException","ForbiddenException","NotFoundException","MethodNotAllowedException","NotAcceptableException","RequestTimeoutException","ConflictException","UpgradeRequiredException","TooManyRequestsException","InternalServerException","NotImplementedException","BadGatewayException","ServiceUnavailableException","GatewayTimeoutException","HttpVersionNotSupportedException","VariantAlsoNegotiatesException","InsufficientStorageException","LoopDetectedException","NotExtendedException","NetworkAuthenticationRequiredException","NetworkConnectTimeoutException","AppInjector","name","bindings","Map","singletons","scoped","createScope","scope","resolve","target","binding","get","InternalServerException","lifetime","instantiate","implementation","has","instance","set","undefined","paramTypes","Reflect","getMetadata","params","map","p","inject","t","RootInjector","import_reflect_metadata","Authorize","guardClasses","target","propertyKey","key","ctrlName","name","actionName","authorizations","has","Error","set","getGuardForController","controllerName","get","getGuardForControllerAction","Map","createRouteDecorator","verb","path","target","propertyKey","existingRoutes","Reflect","getMetadata","ROUTE_METADATA_KEY","metadata","method","trim","replace","handler","guards","getGuardForControllerAction","__controllerName","push","defineMetadata","getRouteMetadata","Get","Post","Put","Patch","Delete","Symbol","Module","metadata","target","checkModule","arr","arrName","clazz","Reflect","getMetadata","MODULE_METADATA_KEY","Error","name","checkInjectable","INJECTABLE_METADATA_KEY","checkController","CONTROLLER_METADATA_KEY","imports","exports","providers","controllers","defineMetadata","Injectable","getModuleMetadata","Symbol","getPrettyTimestamp","now","Date","getDate","toString","padStart","getMonth","getFullYear","getHours","getMinutes","getSeconds","getLogPrefix","callee","messageType","color","timestamp","spaces","repeat","length","process","pid","Logger","colors","initial","toUpperCase","yellow","formatObject","prefix","arg","json","JSON","stringify","prefixedJson","split","map","line","idx","darkGrey","grey","join","formattedArgs","args","getCallee","stack","Error","caller","trim","match","replace","canLog","level","logLevelRank","logLevel","debug","comment","log","info","warn","error","setLogLevel","green","console","blue","brown","red","purple","black","lightRed","lightGreen","lightBlue","magenta","cyan","white","InjectorExplorer","register","target","lifetime","RootInjector","bindings","has","set","implementation","resolve","getModuleMetadata","Logger","log","name","controllerMeta","getControllerMetadata","router","Router","registerController","routeMeta","getRouteMetadata","getInjectableMetadata","Injectable","lifetime","target","prototype","Error","Reflect","defineMetadata","INJECTABLE_METADATA_KEY","InjectorExplorer","register","getInjectableMetadata","getMetadata","Symbol","Controller","path","target","data","guards","getGuardForController","name","Reflect","defineMetadata","CONTROLLER_METADATA_KEY","Injectable","getControllerMetadata","getMetadata","Symbol","UseMiddlewares","mdlw","target","propertyKey","key","ctrlName","name","actionName","middlewares","has","Error","set","getMiddlewaresForController","controllerName","get","getMiddlewaresForControllerAction","Map","RadixNode","segment","children","value","isParam","paramName","startsWith","slice","matchChild","child","undefined","findExactChild","find","c","addChild","node","push","RadixTree","root","insert","path","segments","normalize","insertRecursive","length","search","searchRecursive","params","rest","childParams","result","replace","split","filter","Boolean","Router","routes","RadixTree","rootMiddlewares","registerController","controllerClass","controllerMeta","getControllerMetadata","controllerGuards","getGuardForController","name","controllerMiddlewares","getMiddlewaresForController","Error","routeMetadata","getRouteMetadata","def","fullPath","path","replace","routeGuards","getGuardForControllerAction","handler","routeMiddlewares","getMiddlewaresForControllerAction","guards","Set","middlewares","routeDef","method","controller","insert","hasActionGuards","length","actionGuardsInfo","map","g","join","Logger","log","hasCtrlGuards","controllerGuardsInfo","defineRootMiddleware","middleware","push","handle","request","comment","t0","performance","now","response","requestId","id","status","body","error","undefined","findRoute","resolveController","ResponseException","message","t1","colors","yellow","Math","round","initial","warn","matchedRoutes","search","node","children","NotFoundException","findExactChild","value","MethodNotAllowedException","controllerInstance","context","resolve","Object","assign","params","extractParams","runRequestPipeline","middlewareMaxIndex","guardsMaxIndex","index","dispatch","i","nextFn","bind","runMiddleware","guardIndex","guardType","runGuard","action","call","next","middlewareType","invoke","guard","allowed","canActivate","UnauthorizedException","actual","template","aParts","split","tParts","forEach","part","startsWith","slice","import_reflect_metadata","Request","event","id","method","path","body","context","RootInjector","createScope","params","replace","_ts_decorate","NoxApp","router","messagePorts","Map","app","init","ipcMain","on","giveTheRendererAPort","bind","once","onAppActivated","onAllWindowsClosed","console","log","event","senderId","sender","id","has","shutdownChannel","channel","MessageChannelMain","set","port1","onRendererMessage","start","postMessage","port2","requestId","path","method","body","data","get","Logger","error","request","Request","response","handle","err","status","message","process","platform","BrowserWindow","getAllWindows","length","onActivated","channelSenderId","warn","off","close","delete","forEach","clear","info","dispose","quit","configure","inject","use","middleware","defineRootMiddleware","onReady","import_main","bootstrapApplication","rootModule","getModuleMetadata","Error","app","whenReady","noxApp","inject","NoxApp","init"]}