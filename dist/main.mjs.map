{"version":3,"sources":["../src/DI/app-injector.ts","../src/decorators/inject.decorator.ts","../src/exceptions.ts","../src/utils/forward-ref.ts","../src/router.ts","../src/decorators/guards.decorator.ts","../src/decorators/injectable.metadata.ts","../src/decorators/method.decorator.ts","../src/decorators/module.decorator.ts","../src/utils/logger.ts","../src/DI/injector-explorer.ts","../src/decorators/injectable.decorator.ts","../src/decorators/controller.decorator.ts","../src/decorators/middleware.decorator.ts","../src/request.ts","../src/utils/radix-tree.ts","../src/app.ts","../src/socket.ts","../src/bootstrap.ts","../src/preload-bridge.ts","../src/renderer-events.ts","../src/renderer-client.ts"],"sourcesContent":["/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { INJECT_METADATA_KEY } from 'src/decorators/inject.decorator';\r\nimport { InternalServerException } from 'src/exceptions';\r\nimport { ForwardReference } from 'src/utils/forward-ref';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * Represents a lifetime of a binding in the dependency injection system.\r\n * It can be one of the following:\r\n * - 'singleton': The instance is created once and shared across the application.\r\n * - 'scope': The instance is created once per scope (e.g., per request).\r\n * - 'transient': A new instance is created every time it is requested.\r\n */\r\nexport type Lifetime = 'singleton' | 'scope' | 'transient';\r\n\r\n/**\r\n * Represents a binding in the dependency injection system.\r\n * It contains the lifetime of the binding, the implementation type, and optionally an instance.\r\n */\r\nexport interface IBinding {\r\n    lifetime: Lifetime;\r\n    implementation: Type<unknown>;\r\n    instance?: InstanceType<Type<unknown>>;\r\n}\r\n\r\n/**\r\n * AppInjector is the root dependency injection container.\r\n * It is used to register and resolve dependencies in the application.\r\n * It supports different lifetimes for dependencies:\r\n * This should not be manually instantiated, outside of the framework.\r\n * Use the `RootInjector` instance instead.\r\n */\r\nexport class AppInjector {\r\n    public bindings = new Map<Type<unknown>, IBinding>();\r\n    public singletons = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n    public scoped = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n\r\n    constructor(\r\n        public readonly name: string | null = null,\r\n    ) {}\r\n\r\n    /**\r\n     * Typically used to create a dependency injection scope\r\n     * at the \"scope\" level (i.e., per-request lifetime).\r\n     *\r\n     * SHOULD NOT BE USED by anything else than the framework itself.\r\n     */\r\n    public createScope(): AppInjector {\r\n        const scope = new AppInjector();\r\n        scope.bindings = this.bindings; // pass injectable declarations\r\n        scope.singletons = this.singletons; // share parent's singletons to avoid recreating them\r\n        // do not keep parent's scoped instances\r\n        return scope;\r\n    }\r\n\r\n    /**\r\n     * Called when resolving a dependency,\r\n     * i.e., retrieving the instance of a given class.\r\n     */\r\n    public resolve<T>(target: Type<T> | ForwardReference<T>): T {\r\n        if (target instanceof ForwardReference) {\r\n            return new Proxy({}, {\r\n                get: (obj, prop, receiver) => {\r\n                    const realType = target.forwardRefFn();\r\n                    const instance = this.resolve(realType) as any;\r\n                    const value = Reflect.get(instance, prop, receiver);\r\n                    \r\n                    return typeof value === 'function' ? value.bind(instance) : value;\r\n                },\r\n                set: (obj, prop, value, receiver) => {\r\n                     const realType = target.forwardRefFn();\r\n                     const instance = this.resolve(realType) as any;\r\n                     return Reflect.set(instance, prop, value, receiver);\r\n                },\r\n                getPrototypeOf: () => {\r\n                     const realType = target.forwardRefFn();\r\n                     return (realType as any).prototype;\r\n                }\r\n            }) as T;\r\n        }\r\n\r\n        const binding = this.bindings.get(target);\r\n\r\n        if(!binding) {\r\n            if(target === undefined) {\r\n                throw new InternalServerException(\r\n                    \"Failed to resolve a dependency injection : Undefined target type.\\n\"\r\n                    + \"This might be caused by a circular dependency.\"\r\n                );\r\n            }\r\n\r\n            const name = target.name || \"unknown\";\r\n\r\n            throw new InternalServerException(\r\n                `Failed to resolve a dependency injection : No binding for type ${name}.\\n`\r\n                + `Did you forget to use @Injectable() decorator ?`\r\n            );\r\n        }\r\n\r\n        switch(binding.lifetime) {\r\n            case 'transient':\r\n                return this.instantiate(binding.implementation) as T;\r\n\r\n            case 'scope': {\r\n                if(this.scoped.has(target)) {\r\n                    return this.scoped.get(target) as T;\r\n                }\r\n\r\n                const instance = this.instantiate(binding.implementation);\r\n                this.scoped.set(target, instance);\r\n\r\n                return instance as T;\r\n            }\r\n\r\n            case 'singleton': {\r\n                if(binding.instance === undefined && this.name === 'root') {\r\n                    binding.instance = this.instantiate(binding.implementation);\r\n                    this.singletons.set(target, binding.instance);\r\n                }\r\n\r\n                return binding.instance as T;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a class, resolving its dependencies.\r\n     */\r\n    private instantiate<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];\r\n        const injectParams = Reflect.getMetadata(INJECT_METADATA_KEY, target) || [];\r\n\r\n        const params = paramTypes.map((paramType: any, index: number) => {\r\n            const overrideToken = injectParams[index];\r\n            const actualToken = overrideToken !== undefined ? overrideToken : paramType;\r\n\r\n            return this.resolve(actualToken);\r\n        });\r\n\r\n        return new target(...params) as InstanceType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Injects a type from the dependency injection system.\r\n * This function is used to retrieve an instance of a type that has been registered in the dependency injection system.\r\n * It is typically used in the constructor of a class to inject dependencies.\r\n * @param t - The type to inject.\r\n * @returns An instance of the type.\r\n * @throws If the type is not registered in the dependency injection system.\r\n */\r\nexport function inject<T>(t: Type<T> | ForwardReference<T>): T {\r\n    return RootInjector.resolve(t);\r\n}\r\n\r\nexport const RootInjector = new AppInjector('root');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\n\r\nexport const INJECT_METADATA_KEY = 'custom:inject';\r\n\r\n/**\r\n * Decorator to manually inject a dependency.\r\n * Useful for handling circular dependencies with `forwardRef` or injecting specific tokens.\r\n *\r\n * @param token The token or forward reference to inject.\r\n */\r\nexport function Inject(token: any): ParameterDecorator {\r\n    return (target, propertyKey, parameterIndex) => {\r\n        // target is the constructor for constructor parameters\r\n        const existingParameters = Reflect.getOwnMetadata(INJECT_METADATA_KEY, target) || [];\r\n        existingParameters[parameterIndex] = token;\r\n        Reflect.defineMetadata(INJECT_METADATA_KEY, existingParameters, target);\r\n    };\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport class ResponseException extends Error {\r\n    public readonly status: number = 0;\r\n\r\n    constructor(message?: string);\r\n    constructor(statusCode?: number, message?: string);\r\n    constructor(statusOrMessage?: number | string, message?: string) {\r\n        let statusCode: number | undefined;\r\n        \r\n        if(typeof statusOrMessage === 'number') {\r\n            statusCode = statusOrMessage;\r\n        }\r\n        else if(typeof statusOrMessage === 'string') {\r\n            message = statusOrMessage;\r\n        }\r\n\r\n        super(message ?? \"\");\r\n\r\n        if(statusCode !== undefined) {\r\n            this.status = statusCode;\r\n        }\r\n        \r\n        this.name = this.constructor.name\r\n            .replace(/([A-Z])/g, ' $1');\r\n    }\r\n}\r\n\r\n// 4XX\r\nexport class BadRequestException extends ResponseException { public override readonly status = 400; }\r\nexport class UnauthorizedException extends ResponseException { public override readonly status = 401; }\r\nexport class PaymentRequiredException extends ResponseException { public override readonly status = 402; }\r\nexport class ForbiddenException extends ResponseException { public override readonly status = 403; }\r\nexport class NotFoundException extends ResponseException { public override readonly status = 404; }\r\nexport class MethodNotAllowedException extends ResponseException { public override readonly status = 405; }\r\nexport class NotAcceptableException extends ResponseException { public override readonly status = 406; }\r\nexport class RequestTimeoutException extends ResponseException { public override readonly status = 408; }\r\nexport class ConflictException extends ResponseException { public override readonly status = 409; }\r\nexport class UpgradeRequiredException extends ResponseException { public override readonly status = 426; }\r\nexport class TooManyRequestsException extends ResponseException { public override readonly status = 429; }\r\n// 5XX\r\nexport class InternalServerException extends ResponseException { public override readonly status = 500; }\r\nexport class NotImplementedException extends ResponseException { public override readonly status = 501; }\r\nexport class BadGatewayException extends ResponseException { public override readonly status = 502; }\r\nexport class ServiceUnavailableException extends ResponseException { public override readonly status = 503; }\r\nexport class GatewayTimeoutException extends ResponseException { public override readonly status = 504; }\r\nexport class HttpVersionNotSupportedException extends ResponseException { public override readonly status = 505; }\r\nexport class VariantAlsoNegotiatesException extends ResponseException { public override readonly status = 506; }\r\nexport class InsufficientStorageException extends ResponseException { public override readonly status = 507; }\r\nexport class LoopDetectedException extends ResponseException { public override readonly status = 508; }\r\nexport class NotExtendedException extends ResponseException { public override readonly status = 510; }\r\nexport class NetworkAuthenticationRequiredException extends ResponseException { public override readonly status = 511; }\r\nexport class NetworkConnectTimeoutException extends ResponseException { public override readonly status = 599; }\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Type } from \"./types\";\r\n\r\n/**\r\n * A function that returns a type.\r\n * Used for forward references to types that are not yet defined.\r\n */\r\nexport interface ForwardRefFn<T = any> {\r\n    (): Type<T>;\r\n}\r\n\r\n/**\r\n * A wrapper class for forward referenced types.\r\n */\r\nexport class ForwardReference<T = any> {\r\n    constructor(public readonly forwardRefFn: ForwardRefFn<T>) {}\r\n}\r\n\r\n/**\r\n * Creates a forward reference to a type.\r\n * @param fn A function that returns the type.\r\n * @returns A ForwardReference instance.\r\n */\r\nexport function forwardRef<T = any>(fn: ForwardRefFn<T>): ForwardReference<T> {\r\n    return new ForwardReference(fn);\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { getControllerMetadata } from 'src/decorators/controller.decorator';\r\nimport { getGuardForController, getGuardForControllerAction, IGuard } from 'src/decorators/guards.decorator';\r\nimport { Injectable } from 'src/decorators/injectable.decorator';\r\nimport { AtomicHttpMethod, getRouteMetadata } from 'src/decorators/method.decorator';\r\nimport { getMiddlewaresForController, getMiddlewaresForControllerAction, IMiddleware, NextFunction } from 'src/decorators/middleware.decorator';\r\nimport { BadRequestException, MethodNotAllowedException, NotFoundException, ResponseException, UnauthorizedException } from 'src/exceptions';\r\nimport { IBatchRequestItem, IBatchRequestPayload, IBatchResponsePayload, IResponse, Request } from 'src/request';\r\nimport { Logger } from 'src/utils/logger';\r\nimport { RadixTree } from 'src/utils/radix-tree';\r\nimport { Type } from 'src/utils/types';\r\n\r\nconst ATOMIC_HTTP_METHODS: ReadonlySet<AtomicHttpMethod> = new Set<AtomicHttpMethod>(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']);\r\n\r\nfunction isAtomicHttpMethod(method: unknown): method is AtomicHttpMethod {\r\n    return typeof method === 'string' && ATOMIC_HTTP_METHODS.has(method as AtomicHttpMethod);\r\n}\r\n\r\n/**\r\n * IRouteDefinition interface defines the structure of a route in the application.\r\n * It includes the HTTP method, path, controller class, handler method name,\r\n * guards, and middlewares associated with the route.\r\n */\r\nexport interface IRouteDefinition {\r\n    method: string;\r\n    path: string;\r\n    controller: Type<any>;\r\n    handler: string;\r\n    guards: Type<IGuard>[];\r\n    middlewares: Type<IMiddleware>[];\r\n}\r\n\r\n/**\r\n * This type defines a function that represents an action in a controller.\r\n * It takes a Request and an IResponse as parameters and returns a value or a Promise.\r\n */\r\nexport type ControllerAction = (request: Request, response: IResponse) => any;\r\n\r\n\r\n/**\r\n * Router class is responsible for managing the application's routing.\r\n * It registers controllers, handles requests, and manages middlewares and guards.\r\n */\r\n@Injectable('singleton')\r\nexport class Router {\r\n    private readonly routes = new RadixTree<IRouteDefinition>();\r\n    private readonly rootMiddlewares: Type<IMiddleware>[] = [];\r\n\r\n    /**\r\n     * Registers a controller class with the router.\r\n     * This method extracts the route metadata from the controller class and registers it in the routing tree.\r\n     * It also handles the guards and middlewares associated with the controller.\r\n     * @param controllerClass - The controller class to register.\r\n     */\r\n    public registerController(controllerClass: Type<unknown>): Router {\r\n        const controllerMeta = getControllerMetadata(controllerClass);\r\n\r\n        const controllerGuards = getGuardForController(controllerClass.name);\r\n        const controllerMiddlewares = getMiddlewaresForController(controllerClass.name);\r\n\r\n        if(!controllerMeta)\r\n            throw new Error(`Missing @Controller decorator on ${controllerClass.name}`);\r\n\r\n        const routeMetadata = getRouteMetadata(controllerClass);\r\n\r\n        for(const def of routeMetadata) {\r\n            const fullPath = `${controllerMeta.path}/${def.path}`.replace(/\\/+/g, '/');\r\n\r\n            const routeGuards = getGuardForControllerAction(controllerClass.name, def.handler);\r\n            const routeMiddlewares = getMiddlewaresForControllerAction(controllerClass.name, def.handler);\r\n\r\n            const guards = new Set([...controllerGuards, ...routeGuards]);\r\n            const middlewares = new Set([...controllerMiddlewares, ...routeMiddlewares]);\r\n\r\n            const routeDef: IRouteDefinition = {\r\n                method: def.method,\r\n                path: fullPath,\r\n                controller: controllerClass,\r\n                handler: def.handler,\r\n                guards: [...guards],\r\n                middlewares: [...middlewares],\r\n            };\r\n\r\n            this.routes.insert(fullPath + '/' + def.method, routeDef);\r\n\r\n            const hasActionGuards = routeDef.guards.length > 0;\r\n\r\n            const actionGuardsInfo = hasActionGuards\r\n                ? '<' + routeDef.guards.map(g => g.name).join('|') + '>'\r\n                : '';\r\n\r\n            Logger.log(`Mapped {${routeDef.method} /${fullPath}}${actionGuardsInfo} route`);\r\n        }\r\n\r\n        const hasCtrlGuards = controllerMeta.guards.length > 0;\r\n\r\n        const controllerGuardsInfo = hasCtrlGuards\r\n            ? '<' + controllerMeta.guards.map(g => g.name).join('|') + '>'\r\n            : '';\r\n\r\n        Logger.log(`Mapped ${controllerClass.name}${controllerGuardsInfo} controller's routes`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Defines a middleware for the root of the application.\r\n     * This method allows you to register a middleware that will be applied to all requests\r\n     * to the application, regardless of the controller or action.\r\n     * @param middleware - The middleware class to register.\r\n     */\r\n    public defineRootMiddleware(middleware: Type<IMiddleware>): Router {\r\n        this.rootMiddlewares.push(middleware);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Shuts down the message channel for a specific sender ID.\r\n     * This method closes the IPC channel for the specified sender ID and\r\n     * removes it from the messagePorts map.\r\n     * @param channelSenderId - The ID of the sender channel to shut down.\r\n     */\r\n    public async handle(request: Request): Promise<IResponse> {\r\n        if(request.method === 'BATCH') {\r\n            return this.handleBatch(request);\r\n        }\r\n\r\n        return this.handleAtomic(request);\r\n    }\r\n\r\n    private async handleAtomic(request: Request): Promise<IResponse> {\r\n        Logger.comment(`>     ${request.method} /${request.path}`);\r\n\r\n        const t0 = performance.now();\r\n\r\n        const response: IResponse = {\r\n            requestId: request.id,\r\n            status: 200,\r\n            body: null,\r\n        };\r\n\r\n        let isCritical: boolean = false;\r\n\r\n        try {\r\n            const routeDef = this.findRoute(request);\r\n            await this.resolveController(request, response, routeDef);\r\n\r\n            if(response.status > 400) {\r\n                throw new ResponseException(response.status, response.error);\r\n            }\r\n        }\r\n        catch(error: unknown) {\r\n            response.body = undefined;\r\n\r\n            if(error instanceof ResponseException) {\r\n                response.status = error.status;\r\n                response.error = error.message;\r\n                response.stack = error.stack;\r\n            }\r\n            else if(error instanceof Error) {\r\n                isCritical = true;\r\n                response.status = 500;\r\n                response.error = error.message || 'Internal Server Error';\r\n                response.stack = error.stack || 'No stack trace available';\r\n            }\r\n            else {\r\n                isCritical = true;\r\n                response.status = 500;\r\n                response.error = 'Unknown error occurred';\r\n                response.stack = 'No stack trace available';\r\n            }\r\n        }\r\n        finally {\r\n            const t1 = performance.now();\r\n\r\n            const message = `< ${response.status} ${request.method} /${request.path} ${Logger.colors.yellow}${Math.round(t1 - t0)}ms${Logger.colors.initial}`;\r\n\r\n            if(response.status < 400) {\r\n                Logger.log(message);\r\n            }\r\n            else if(response.status < 500) {\r\n                Logger.warn(message);\r\n            }\r\n            else {\r\n                if(isCritical) {\r\n                    Logger.critical(message);\r\n                }\r\n                else {\r\n                    Logger.error(message);\r\n                }\r\n            }\r\n\r\n            if(response.error !== undefined) {\r\n                if(isCritical) {\r\n                    Logger.critical(response.error);\r\n                }\r\n                else {\r\n                    Logger.error(response.error);\r\n                }\r\n\r\n                if(response.stack !== undefined) {\r\n                    Logger.errorStack(response.stack);\r\n                }\r\n            }\r\n\r\n            return response;\r\n        }\r\n    }\r\n\r\n    private async handleBatch(request: Request): Promise<IResponse> {\r\n        Logger.comment(`>     ${request.method} /${request.path}`);\r\n\r\n        const t0 = performance.now();\r\n\r\n        const response: IResponse<IBatchResponsePayload> = {\r\n            requestId: request.id,\r\n            status: 200,\r\n            body: { responses: [] },\r\n        };\r\n\r\n        let isCritical: boolean = false;\r\n\r\n        try {\r\n            const payload = this.normalizeBatchPayload(request.body);\r\n            const batchResponses: IResponse[] = [];\r\n\r\n            for(const [index, item] of payload.requests.entries()) {\r\n                const subRequestId = item.requestId ?? `${request.id}:${index}`;\r\n                const atomicRequest = new Request(request.event, request.senderId, subRequestId, item.method, item.path, item.body);\r\n                batchResponses.push(await this.handleAtomic(atomicRequest));\r\n            }\r\n\r\n            response.body!.responses = batchResponses;\r\n        }\r\n        catch(error: unknown) {\r\n            response.body = undefined;\r\n\r\n            if(error instanceof ResponseException) {\r\n                response.status = error.status;\r\n                response.error = error.message;\r\n                response.stack = error.stack;\r\n            }\r\n            else if(error instanceof Error) {\r\n                isCritical = true;\r\n                response.status = 500;\r\n                response.error = error.message || 'Internal Server Error';\r\n                response.stack = error.stack || 'No stack trace available';\r\n            }\r\n            else {\r\n                isCritical = true;\r\n                response.status = 500;\r\n                response.error = 'Unknown error occurred';\r\n                response.stack = 'No stack trace available';\r\n            }\r\n        }\r\n        finally {\r\n            const t1 = performance.now();\r\n\r\n            const message = `< ${response.status} ${request.method} /${request.path} ${Logger.colors.yellow}${Math.round(t1 - t0)}ms${Logger.colors.initial}`;\r\n\r\n            if(response.status < 400) {\r\n                Logger.log(message);\r\n            }\r\n            else if(response.status < 500) {\r\n                Logger.warn(message);\r\n            }\r\n            else {\r\n                if(isCritical) {\r\n                    Logger.critical(message);\r\n                }\r\n                else {\r\n                    Logger.error(message);\r\n                }\r\n            }\r\n\r\n            if(response.error !== undefined) {\r\n                if(isCritical) {\r\n                    Logger.critical(response.error);\r\n                }\r\n                else {\r\n                    Logger.error(response.error);\r\n                }\r\n\r\n                if(response.stack !== undefined) {\r\n                    Logger.errorStack(response.stack);\r\n                }\r\n            }\r\n\r\n            return response;\r\n        }\r\n    }\r\n\r\n    private normalizeBatchPayload(body: unknown): IBatchRequestPayload {\r\n        if(body === null || typeof body !== 'object') {\r\n            throw new BadRequestException('Batch payload must be an object containing a requests array.');\r\n        }\r\n\r\n        const possiblePayload = body as Partial<IBatchRequestPayload>;\r\n        const { requests } = possiblePayload;\r\n\r\n        if(!Array.isArray(requests)) {\r\n            throw new BadRequestException('Batch payload must define a requests array.');\r\n        }\r\n\r\n        const normalizedRequests = requests.map((entry, index) => this.normalizeBatchItem(entry, index));\r\n\r\n        return { requests: normalizedRequests };\r\n    }\r\n\r\n    private normalizeBatchItem(entry: unknown, index: number): IBatchRequestItem {\r\n        if(entry === null || typeof entry !== 'object') {\r\n            throw new BadRequestException(`Batch request at index ${index} must be an object.`);\r\n        }\r\n\r\n        const { requestId, path, method, body } = entry as Partial<IBatchRequestItem> & { method?: unknown };\r\n\r\n        if(requestId !== undefined && typeof requestId !== 'string') {\r\n            throw new BadRequestException(`Batch request at index ${index} has an invalid requestId.`);\r\n        }\r\n\r\n        if(typeof path !== 'string' || path.length === 0) {\r\n            throw new BadRequestException(`Batch request at index ${index} must define a non-empty path.`);\r\n        }\r\n\r\n        if(typeof method !== 'string') {\r\n            throw new BadRequestException(`Batch request at index ${index} must define an HTTP method.`);\r\n        }\r\n\r\n        const normalizedMethod = method.toUpperCase();\r\n\r\n        if(!isAtomicHttpMethod(normalizedMethod)) {\r\n            throw new BadRequestException(`Batch request at index ${index} uses the unsupported method ${method}.`);\r\n        }\r\n\r\n        return {\r\n            requestId,\r\n            path,\r\n            method: normalizedMethod as AtomicHttpMethod,\r\n            body,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the route definition for a given request.\r\n     * This method searches the routing tree for a matching route based on the request's path and method.\r\n     * If no matching route is found, it throws a NotFoundException.\r\n     * @param request - The Request object containing the method and path to search for.\r\n     * @returns The IRouteDefinition for the matched route.\r\n     */\r\n    private findRoute(request: Request): IRouteDefinition {\r\n        const matchedRoutes = this.routes.search(request.path);\r\n\r\n        if(matchedRoutes?.node === undefined || matchedRoutes.node.children.length === 0) {\r\n            throw new NotFoundException(`No route matches ${request.method} ${request.path}`);\r\n        }\r\n\r\n        const routeDef = matchedRoutes.node.findExactChild(request.method);\r\n\r\n        if(routeDef?.value === undefined) {\r\n            throw new MethodNotAllowedException(`Method Not Allowed for ${request.method} ${request.path}`);\r\n        }\r\n\r\n        return routeDef.value;\r\n    }\r\n\r\n    /**\r\n     * Resolves the controller for a given route definition.\r\n     * This method creates an instance of the controller class and prepares the request parameters.\r\n     * It also runs the request pipeline, which includes executing middlewares and guards.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param routeDef - The IRouteDefinition for the matched route.\r\n     * @return A Promise that resolves when the controller action has been executed.\r\n     * @throws UnauthorizedException if the request is not authorized by the guards.\r\n     */\r\n    private async resolveController(request: Request, response: IResponse, routeDef: IRouteDefinition): Promise<void> {\r\n        const controllerInstance = request.context.resolve(routeDef.controller);\r\n\r\n        Object.assign(request.params, this.extractParams(request.path, routeDef.path));\r\n\r\n        await this.runRequestPipeline(request, response, routeDef, controllerInstance);\r\n    }\r\n\r\n    /**\r\n     * Runs the request pipeline for a given request.\r\n     * This method executes the middlewares and guards associated with the route,\r\n     * and finally calls the controller action.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param routeDef - The IRouteDefinition for the matched route.\r\n     * @param controllerInstance - The instance of the controller class.\r\n     * @return A Promise that resolves when the request pipeline has been executed.\r\n     * @throws ResponseException if the response status is not successful.\r\n     */\r\n    private async runRequestPipeline(request: Request, response: IResponse, routeDef: IRouteDefinition, controllerInstance: any): Promise<void> {\r\n        const middlewares = [...new Set([...this.rootMiddlewares, ...routeDef.middlewares])];\r\n\r\n        const middlewareMaxIndex = middlewares.length - 1;\r\n        const guardsMaxIndex = middlewareMaxIndex + routeDef.guards.length;\r\n\r\n        let index = -1;\r\n\r\n        const dispatch = async (i: number): Promise<void> => {\r\n            if(i <= index)\r\n                throw new Error(\"next() called multiple times\");\r\n\r\n            index = i;\r\n\r\n            // middlewares\r\n            if(i <= middlewareMaxIndex) {\r\n                const nextFn = dispatch.bind(null, i + 1);\r\n                await this.runMiddleware(request, response, nextFn, middlewares[i]!);\r\n\r\n                if(response.status >= 400) {\r\n                    throw new ResponseException(response.status, response.error);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            // guards\r\n            if(i <= guardsMaxIndex) {\r\n                const guardIndex = i - middlewares.length;\r\n                const guardType = routeDef.guards[guardIndex]!;\r\n                await this.runGuard(request, guardType);\r\n                await dispatch(i + 1);\r\n                return;\r\n            }\r\n\r\n            // endpoint action\r\n            const action = controllerInstance[routeDef.handler] as ControllerAction;\r\n            response.body = await action.call(controllerInstance, request, response);\r\n\r\n            // avoid parsing error on the renderer if the action just does treatment without returning anything\r\n            if(response.body === undefined) {\r\n                response.body = {};\r\n            }\r\n        };\r\n\r\n        await dispatch(0);\r\n    }\r\n\r\n    /**\r\n     * Runs a middleware function in the request pipeline.\r\n     * This method creates an instance of the middleware and invokes its `invoke` method,\r\n     * passing the request, response, and next function.\r\n     * @param request - The Request object containing the request data.\r\n     * @param response - The IResponse object to populate with the response data.\r\n     * @param next - The NextFunction to call to continue the middleware chain.\r\n     * @param middlewareType - The type of the middleware to run.\r\n     * @return A Promise that resolves when the middleware has been executed.\r\n     */\r\n    private async runMiddleware(request: Request, response: IResponse, next: NextFunction, middlewareType: Type<IMiddleware>): Promise<void> {\r\n        const middleware = request.context.resolve(middlewareType);\r\n        await middleware.invoke(request, response, next);\r\n    }\r\n\r\n    /**\r\n     * Runs a guard to check if the request is authorized.\r\n     * This method creates an instance of the guard and calls its `canActivate` method.\r\n     * If the guard returns false, it throws an UnauthorizedException.\r\n     * @param request - The Request object containing the request data.\r\n     * @param guardType - The type of the guard to run.\r\n     * @return A Promise that resolves if the guard allows the request, or throws an UnauthorizedException if not.\r\n     * @throws UnauthorizedException if the guard denies access to the request.\r\n     */\r\n    private async runGuard(request: Request, guardType: Type<IGuard>): Promise<void> {\r\n        const guard = request.context.resolve(guardType);\r\n        const allowed = await guard.canActivate(request);\r\n\r\n        if(!allowed)\r\n            throw new UnauthorizedException(`Unauthorized for ${request.method} ${request.path}`);\r\n    }\r\n\r\n    /**\r\n     * Extracts parameters from the actual request path based on the template path.\r\n     * This method splits the actual path and the template path into segments,\r\n     * then maps the segments to parameters based on the template.\r\n     * @param actual - The actual request path.\r\n     * @param template - The template path to extract parameters from.\r\n     * @returns An object containing the extracted parameters.\r\n     */\r\n    private extractParams(actual: string, template: string): Record<string, string> {\r\n        const aParts = actual.split('/');\r\n        const tParts = template.split('/');\r\n        const params: Record<string, string> = {};\r\n\r\n        tParts.forEach((part, i) => {\r\n            if(part.startsWith(':')) {\r\n                params[part.slice(1)] = aParts[i] ?? '';\r\n            }\r\n        });\r\n\r\n        return params;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Request } from 'src/request';\r\nimport { Logger } from 'src/utils/logger';\r\nimport { MaybeAsync, Type } from 'src/utils/types';\r\n\r\n/**\r\n * IGuard interface defines a guard that can be used to protect routes.\r\n * It has a `canActivate` method that takes a request and returns a MaybeAsync boolean.\r\n * The `canActivate` method can return either a value or a Promise.\r\n * Use it on a class that should be registered as a guard in the application.\r\n * Guards can be used to protect routes or controller actions.\r\n * For example, you can use guards to check if the user is authenticated or has the right permissions.\r\n * You can use the `Authorize` decorator to register guards for a controller or a controller action.\r\n * @see Authorize\r\n */\r\nexport interface IGuard {\r\n    canActivate(request: Request): MaybeAsync<boolean>;\r\n}\r\n\r\n/**\r\n * Can be used to protect the routes of a controller.\r\n * Can be used on a controller class or on a controller method.\r\n */\r\nexport function Authorize(...guardClasses: Type<IGuard>[]): MethodDecorator & ClassDecorator {\r\n    return (target: Function | object, propertyKey?: string | symbol) => {\r\n        let key: string;\r\n\r\n        // Method decorator\r\n        if(propertyKey) {\r\n            const ctrlName = target.constructor.name;\r\n            const actionName = propertyKey as string;\r\n            key = `${ctrlName}.${actionName}`;\r\n        }\r\n        // Class decorator\r\n        else {\r\n            const ctrlName = (target as Type<unknown>).name;\r\n            key = `${ctrlName}`;\r\n        }\r\n\r\n        if(authorizations.has(key)) {\r\n            throw new Error(`Guard(s) already registered for ${key}`);\r\n        }\r\n\r\n        authorizations.set(key, guardClasses);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the guards for a controller or a controller action.\r\n * @param controllerName The name of the controller to get the guards for.\r\n * @returns An array of guards for the controller.\r\n */\r\nexport function getGuardForController(controllerName: string): Type<IGuard>[] {\r\n    const key = `${controllerName}`;\r\n    return authorizations.get(key) ?? [];\r\n}\r\n\r\n/**\r\n * Gets the guards for a controller action.\r\n * @param controllerName The name of the controller to get the guards for.\r\n * @param actionName The name of the action to get the guards for.\r\n * @returns An array of guards for the controller action.\r\n */\r\nexport function getGuardForControllerAction(controllerName: string, actionName: string): Type<IGuard>[] {\r\n    const key = `${controllerName}.${actionName}`;\r\n    return authorizations.get(key) ?? [];\r\n}\r\n\r\nconst authorizations = new Map<string, Type<IGuard>[]>();\r\n","import type { Lifetime } from \"src/DI/app-injector\";\r\n\r\nexport const INJECTABLE_METADATA_KEY = Symbol(\"INJECTABLE_METADATA_KEY\");\r\n\r\nexport function defineInjectableMetadata(target: Function, lifetime: Lifetime): void {\r\n    Reflect.defineMetadata(INJECTABLE_METADATA_KEY, lifetime, target);\r\n}\r\n\r\nexport function getInjectableMetadata(target: Function): Lifetime | undefined {\r\n    return Reflect.getMetadata(INJECTABLE_METADATA_KEY, target) as Lifetime | undefined;\r\n}\r\n\r\nexport function hasInjectableMetadata(target: Function): boolean {\r\n    return Reflect.hasMetadata(INJECTABLE_METADATA_KEY, target);\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getGuardForControllerAction, IGuard } from \"src/decorators/guards.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * IRouteMetadata interface defines the metadata for a route.\r\n * It includes the HTTP method, path, handler name, and guards associated with the route.\r\n * This metadata is used to register the route in the application.\r\n * This is the configuration that waits a route's decorator.\r\n */\r\nexport interface IRouteMetadata {\r\n    method: HttpMethod;\r\n    path: string;\r\n    handler: string;\r\n    guards: Type<IGuard>[];\r\n}\r\n\r\n/**\r\n * The different HTTP methods that can be used in the application.\r\n */\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'BATCH';\r\n\r\n/**\r\n * Atomic HTTP verbs supported by controllers. BATCH is handled at the router level only.\r\n */\r\nexport type AtomicHttpMethod = Exclude<HttpMethod, 'BATCH'>;\r\n\r\n/**\r\n * The configuration that waits a route's decorator.\r\n * It contains the HTTP method, path, handler, and guards for the route.\r\n * @param verb The HTTP method for the route.\r\n * @returns A method decorator that registers the route with the specified HTTP method.\r\n */\r\nfunction createRouteDecorator(verb: HttpMethod): (path: string) => MethodDecorator {\r\n    return (path: string): MethodDecorator => {\r\n        return (target, propertyKey) => {\r\n            const existingRoutes: IRouteMetadata[] = Reflect.getMetadata(ROUTE_METADATA_KEY, target.constructor) || [];\r\n\r\n            const metadata: IRouteMetadata = {\r\n                method: verb,\r\n                path: path.trim().replace(/^\\/|\\/$/g, ''),\r\n                handler: propertyKey as string,\r\n                guards: getGuardForControllerAction((target.constructor as any).__controllerName, propertyKey as string),\r\n            };\r\n\r\n            existingRoutes.push(metadata);\r\n\r\n            Reflect.defineMetadata(ROUTE_METADATA_KEY, existingRoutes, target.constructor);\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the route metadata for a given target class.\r\n * This metadata includes the HTTP method, path, handler, and guards defined by the route decorators.\r\n * @see Get\r\n * @see Post\r\n * @see Put\r\n * @see Patch\r\n * @see Delete\r\n * @param target The target class to get the route metadata from.\r\n * @returns An array of route metadata if it exists, otherwise an empty array.\r\n */\r\nexport function getRouteMetadata(target: Type<unknown>): IRouteMetadata[] {\r\n    return Reflect.getMetadata(ROUTE_METADATA_KEY, target) || [];\r\n}\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the GET method.\r\n */\r\nexport const Get = createRouteDecorator('GET');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the POST method.\r\n */\r\nexport const Post = createRouteDecorator('POST');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the PUT method.\r\n */\r\nexport const Put = createRouteDecorator('PUT');\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the PATCH method.\r\n */\r\nexport const Patch = createRouteDecorator('PATCH');\r\n\r\n/**\r\n * Route decorator that defines a leaf in the routing tree, attaching it to a controller method\r\n * that will be called when the route is matched.\r\n * This route will have to be called with the DELETE method.\r\n */\r\nexport const Delete = createRouteDecorator('DELETE');\r\n\r\nexport const ROUTE_METADATA_KEY = Symbol('ROUTE_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { CONTROLLER_METADATA_KEY } from \"src/decorators/controller.decorator\";\r\nimport { Injectable, INJECTABLE_METADATA_KEY } from \"src/decorators/injectable.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\nexport interface IModuleMetadata {\r\n    imports?: Type<unknown>[];\r\n    exports?: Type<unknown>[];\r\n    providers?: Type<unknown>[];\r\n    controllers?: Type<unknown>[];\r\n}\r\n\r\n/**\r\n * Module decorator is used to define a module in the application.\r\n * It is a kind of node in the routing tree, that can contains controllers, services, and other modules.\r\n *\r\n * @param metadata - The metadata for the module.\r\n */\r\nexport function Module(metadata: IModuleMetadata): ClassDecorator {\r\n    return (target: Function) => {\r\n        // Validate imports and exports: must be decorated with @Module\r\n        const checkModule = (arr?: Type<unknown>[], arrName?: string): void => {\r\n            if(!arr)\r\n                return;\r\n\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(MODULE_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in ${arrName} must be decorated with @Module`);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Validate providers: must be decorated with @Injectable\r\n        const checkInjectable = (arr?: Type<unknown>[]): void => {\r\n            if(!arr)\r\n                return;\r\n\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(INJECTABLE_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in providers must be decorated with @Injectable`);\r\n                }\r\n            }\r\n        };\r\n\r\n        // Validate controllers: must be decorated with @Controller\r\n        const checkController = (arr?: Type<unknown>[]): void => {\r\n            if(!arr) return;\r\n            for(const clazz of arr) {\r\n                if(!Reflect.getMetadata(CONTROLLER_METADATA_KEY, clazz)) {\r\n                    throw new Error(`Class ${clazz.name} in controllers must be decorated with @Controller`);\r\n                }\r\n            }\r\n        };\r\n\r\n        checkModule(metadata.imports, 'imports');\r\n        checkModule(metadata.exports, 'exports');\r\n        checkInjectable(metadata.providers);\r\n        checkController(metadata.controllers);\r\n\r\n        Reflect.defineMetadata(MODULE_METADATA_KEY, metadata, target);\r\n\r\n        Injectable('singleton')(target);\r\n    };\r\n}\r\n\r\nexport function getModuleMetadata(target: Function): IModuleMetadata | undefined {\r\n    return Reflect.getMetadata(MODULE_METADATA_KEY, target);\r\n}\r\n\r\nexport const MODULE_METADATA_KEY = Symbol('MODULE_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Logger is a utility class for logging messages to the console.\r\n */\r\nexport type LogLevel =\r\n    | 'debug'\r\n    | 'comment'\r\n    | 'log'\r\n    | 'info'\r\n    | 'warn'\r\n    | 'error'\r\n    | 'critical'\r\n;\r\n\r\ninterface FileLogState {\r\n    queue: string[];\r\n    isWriting: boolean;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Returns a formatted timestamp for logging.\r\n */\r\nfunction getPrettyTimestamp(): string {\r\n    const now = new Date();\r\n    return `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear()}`\r\n        + ` ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;\r\n}\r\n\r\n/**\r\n * Generates a log prefix for the console output.\r\n * @param callee - The name of the function or class that is logging the message.\r\n * @param messageType - The type of message being logged (e.g., 'log', 'info', 'warn', 'error', 'debug').\r\n * @param color - The color to use for the log message.\r\n * @returns A formatted string that includes the timestamp, process ID, message type, and callee name.\r\n */\r\nfunction getLogPrefix(callee: string, messageType: string, color?: string): string {\r\n    const timestamp = getPrettyTimestamp();\r\n\r\n    const spaces = \" \".repeat(10 - messageType.length);\r\n\r\n    let colReset = Logger.colors.initial;\r\n    let colCallee = Logger.colors.yellow;\r\n\r\n    if(color === undefined) {\r\n        color = \"\";\r\n        colReset = \"\";\r\n        colCallee = \"\";\r\n    }\r\n\r\n    return `${color}[APP] ${process.pid} - ${colReset}`\r\n        + `${timestamp}${spaces}`\r\n        + `${color}${messageType.toUpperCase()}${colReset} `\r\n        + `${colCallee}[${callee}]${colReset}`;\r\n}\r\n\r\n/**\r\n * Formats an object into a string representation for logging.\r\n * It converts the object to JSON and adds indentation for readability.\r\n * @param prefix - The prefix to use for the formatted object.\r\n * @param arg - The object to format.\r\n * @returns A formatted string representation of the object, with each line prefixed by the specified prefix.\r\n */\r\nfunction formatObject(prefix: string, arg: object, enableColor: boolean = true): string {\r\n    const json = JSON.stringify(arg, null, 2);\r\n\r\n    let colStart = \"\";\r\n    let colLine = \"\";\r\n    let colReset = \"\";\r\n\r\n    if(enableColor) {\r\n        colStart = Logger.colors.darkGrey;\r\n        colLine = Logger.colors.grey;\r\n        colReset = Logger.colors.initial;\r\n    }\r\n\r\n    const prefixedJson = json\r\n        .split('\\n')\r\n        .map((line, idx) => idx === 0 ? `${colStart}${line}` : `${prefix} ${colLine}${line}`)\r\n        .join('\\n') + colReset;\r\n\r\n    return prefixedJson;\r\n}\r\n\r\n/**\r\n * Formats the arguments for logging.\r\n * It colors strings and formats objects with indentation.\r\n * This function is used to prepare the arguments for console output.\r\n * @param prefix - The prefix to use for the formatted arguments.\r\n * @param args - The arguments to format.\r\n * @param color - The color to use for the formatted arguments.\r\n * @returns An array of formatted arguments, where strings are colored and objects are formatted with indentation.\r\n */\r\nfunction formattedArgs(prefix: string, args: any[], color?: string): any[] {\r\n    let colReset = Logger.colors.initial;\r\n\r\n    if(color === undefined) {\r\n        color = \"\";\r\n        colReset = \"\";\r\n    }\r\n\r\n    return args.map(arg => {\r\n        if(typeof arg === \"string\") {\r\n            return `${color}${arg}${colReset}`;\r\n        }\r\n\r\n        else if(typeof arg === \"object\") {\r\n            return formatObject(prefix, arg, color !== \"\");\r\n        }\r\n\r\n        return arg;\r\n    });\r\n}\r\n\r\n/**\r\n * Gets the name of the caller function or class from the stack trace.\r\n * This function is used to determine the context of the log message.\r\n * @returns The name of the caller function or class.\r\n */\r\nfunction getCallee(): string {\r\n    const stack = new Error().stack?.split('\\n') ?? [];\r\n    const caller = stack[3]\r\n        ?.trim()\r\n        .match(/at (.+?)(?:\\..+)? .+$/)\r\n        ?.[1]\r\n        ?.replace(\"Object\", \"\")\r\n        .replace(/^_/, \"\")\r\n        || \"App\";\r\n    return caller;\r\n}\r\n\r\n/**\r\n * Checks if the current log level allows logging the specified level.\r\n * This function compares the current log level with the specified level to determine if logging should occur.\r\n * @param level - The log level to check.\r\n * @returns A boolean indicating whether the log level is enabled.\r\n */\r\nfunction canLog(level: LogLevel): boolean {\r\n    return logLevels.has(level);\r\n}\r\n\r\n/**\r\n * Writes a log message to a file asynchronously to avoid blocking the event loop.\r\n * It batches messages if writing is already in progress.\r\n * @param filepath - The path to the log file.\r\n */\r\nfunction processLogQueue(filepath: string): void {\r\n    const state = fileStates.get(filepath);\r\n\r\n    if(!state || state.isWriting || state.queue.length === 0) {\r\n        return;\r\n    }\r\n\r\n    state.isWriting = true;\r\n\r\n    // Optimization: Grab all pending messages to write in one go\r\n    const messagesToWrite = state.queue.join('\\n') + '\\n';\r\n    state.queue = []; // Clear the queue immediately\r\n\r\n    const dir = path.dirname(filepath);\r\n\r\n    // Using async IO to allow other operations\r\n    fs.mkdir(dir, { recursive: true }, (err) => {\r\n        if(err) {\r\n            console.error(`[Logger] Failed to create directory ${dir}`, err);\r\n            state.isWriting = false;\r\n            return;\r\n        }\r\n\r\n        fs.appendFile(filepath, messagesToWrite, { encoding: \"utf-8\" }, (err) => {\r\n            state.isWriting = false;\r\n\r\n            if(err) {\r\n                console.error(`[Logger] Failed to write log to ${filepath}`, err);\r\n            }\r\n\r\n            // If new messages arrived while we were writing, process them now\r\n            if(state.queue.length > 0) {\r\n                processLogQueue(filepath);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Adds a message to the file queue and triggers processing.\r\n */\r\nfunction enqueue(filepath: string, message: string): void {\r\n    if(!fileStates.has(filepath)) {\r\n        fileStates.set(filepath, { queue: [], isWriting: false });\r\n    }\r\n\r\n    const state = fileStates.get(filepath)!;\r\n    state.queue.push(message);\r\n\r\n    processLogQueue(filepath);\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction output(level: LogLevel, args: any[]): void {\r\n    if(!canLog(level)) {\r\n        return;\r\n    }\r\n\r\n    const callee = getCallee();\r\n\r\n    {\r\n        const prefix = getLogPrefix(callee, level, logLevelColors[level]);\r\n        const data = formattedArgs(prefix, args, logLevelColors[level]);\r\n\r\n        logLevelChannel[level](prefix, ...data);\r\n    }\r\n\r\n    {\r\n        const prefix = getLogPrefix(callee, level);\r\n        const data = formattedArgs(prefix, args);\r\n\r\n        const filepath = fileSettings.get(level)?.filepath;\r\n\r\n        if(filepath) {\r\n            const message = prefix + \" \" + data.join(\" \").replace(/\\x1b\\[[0-9;]*m/g, ''); // Remove ANSI codes\r\n            enqueue(filepath, message);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nexport namespace Logger {\r\n\r\n    /**\r\n     * Sets the log level for the logger.\r\n     * This function allows you to change the log level dynamically at runtime.\r\n     * This won't affect the startup logs.\r\n     *\r\n     * If the parameter is a single LogLevel, all log levels with equal or higher severity will be enabled.\r\n\r\n    * If the parameter is an array of LogLevels, only the specified levels will be enabled.\r\n     *\r\n     * @param level Sets the log level for the logger.\r\n     */\r\n    export function setLogLevel(level: LogLevel | LogLevel[]): void {\r\n        logLevels.clear();\r\n\r\n        if(Array.isArray(level)) {\r\n            for(const lvl of level) {\r\n                logLevels.add(lvl);\r\n            }\r\n        }\r\n        else {\r\n            const targetRank = logLevelRank[level];\r\n\r\n            for(const [lvl, rank] of Object.entries(logLevelRank) as [LogLevel, number][]) {\r\n                if(rank >= targetRank) {\r\n                    logLevels.add(lvl);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level LOG.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function log(...args: any[]): void {\r\n        output(\"log\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level INFO.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function info(...args: any[]): void {\r\n        output(\"info\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level WARN.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function warn(...args: any[]): void {\r\n        output(\"warn\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level ERROR.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function error(...args: any[]): void {\r\n        output(\"error\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level ERROR and a grey color scheme.\r\n     */\r\n    export function errorStack(...args: any[]): void {\r\n        output(\"error\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level DEBUG.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function debug(...args: any[]): void {\r\n        output(\"debug\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level COMMENT.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function comment(...args: any[]): void {\r\n        output(\"comment\", args);\r\n    }\r\n\r\n    /**\r\n     * Logs a message to the console with log level CRITICAL.\r\n     * This function formats the message with a timestamp, process ID, and the name of the caller function or class.\r\n     * It uses different colors for different log levels to enhance readability.\r\n     * @param args The arguments to log.\r\n     */\r\n    export function critical(...args: any[]): void {\r\n        output(\"critical\", args);\r\n    }\r\n\r\n    /**\r\n     * Enables logging to a file output for the specified log levels.\r\n     * @param filepath The path to the log file.\r\n     * @param levels The log levels to enable file logging for. Defaults to all levels.\r\n     */\r\n    export function enableFileLogging(filepath: string, levels: LogLevel[] = [\"debug\", \"comment\", \"log\", \"info\", \"warn\", \"error\", \"critical\"]): void {\r\n        for(const level of levels) {\r\n            fileSettings.set(level, { filepath });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables logging to a file output for the specified log levels.\r\n     * @param levels The log levels to disable file logging for. Defaults to all levels.\r\n     */\r\n    export function disableFileLogging(levels: LogLevel[] = [\"debug\", \"comment\", \"log\", \"info\", \"warn\", \"error\", \"critical\"]): void {\r\n        for(const level of levels) {\r\n            fileSettings.delete(level);\r\n        }\r\n    }\r\n\r\n\r\n    export const colors = {\r\n        black: \"\\x1b[0;30m\",\r\n        grey: \"\\x1b[0;37m\",\r\n        red: \"\\x1b[0;31m\",\r\n        green: \"\\x1b[0;32m\",\r\n        brown: \"\\x1b[0;33m\",\r\n        blue: \"\\x1b[0;34m\",\r\n        purple: \"\\x1b[0;35m\",\r\n\r\n        darkGrey: \"\\x1b[1;30m\",\r\n        lightRed: \"\\x1b[1;31m\",\r\n        lightGreen: \"\\x1b[1;32m\",\r\n        yellow: \"\\x1b[1;33m\",\r\n        lightBlue: \"\\x1b[1;34m\",\r\n        magenta: \"\\x1b[1;35m\",\r\n        cyan: \"\\x1b[1;36m\",\r\n        white: \"\\x1b[1;37m\",\r\n\r\n        initial: \"\\x1b[0m\"\r\n    };\r\n}\r\n\r\n\r\nconst fileSettings: Map<LogLevel, { filepath: string }> = new Map();\r\nconst fileStates: Map<string, FileLogState> = new Map(); // filepath -> state\r\n\r\nconst logLevels: Set<LogLevel> = new Set();\r\n\r\nconst logLevelRank: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    comment: 1,\r\n    log: 2,\r\n    info: 3,\r\n    warn: 4,\r\n    error: 5,\r\n    critical: 6,\r\n};\r\n\r\nconst logLevelColors: Record<LogLevel, string> = {\r\n    debug: Logger.colors.purple,\r\n    comment: Logger.colors.grey,\r\n    log: Logger.colors.green,\r\n    info: Logger.colors.blue,\r\n    warn: Logger.colors.brown,\r\n    error: Logger.colors.red,\r\n    critical: Logger.colors.lightRed,\r\n};\r\n\r\nconst logLevelChannel: Record<LogLevel, (message?: any, ...optionalParams: any[]) => void> = {\r\n    debug: console.debug,\r\n    comment: console.debug,\r\n    log: console.log,\r\n    info: console.info,\r\n    warn: console.warn,\r\n    error: console.error,\r\n    critical: console.error,\r\n};\r\n\r\n\r\nLogger.setLogLevel(\"debug\");\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getControllerMetadata } from \"src/decorators/controller.decorator\";\r\nimport { getInjectableMetadata } from \"src/decorators/injectable.metadata\";\r\nimport { getRouteMetadata } from \"src/decorators/method.decorator\";\r\nimport { getModuleMetadata } from \"src/decorators/module.decorator\";\r\nimport { Lifetime, RootInjector } from \"src/DI/app-injector\";\r\nimport { Router } from \"src/router\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * InjectorExplorer is a utility class that explores the dependency injection system at the startup.\r\n */\r\nexport class InjectorExplorer {\r\n    /**\r\n     * Registers the class as injectable.\r\n     * When a class is instantiated, if it has dependencies and those dependencies\r\n     * are listed using this method, they will be injected into the class constructor.\r\n     */\r\n    public static register(target: Type<unknown>, lifetime: Lifetime): typeof RootInjector {\r\n        if(RootInjector.bindings.has(target)) // already registered\r\n            return RootInjector;\r\n\r\n        RootInjector.bindings.set(target, {\r\n            implementation: target,\r\n            lifetime\r\n        });\r\n\r\n        if(lifetime === 'singleton') {\r\n            RootInjector.resolve(target);\r\n        }\r\n\r\n        if(getModuleMetadata(target)) {\r\n            Logger.log(`${target.name} dependencies initialized`);\r\n            return RootInjector;\r\n        }\r\n\r\n        const controllerMeta = getControllerMetadata(target);\r\n\r\n        if(controllerMeta) {\r\n            const router = RootInjector.resolve(Router);\r\n            router?.registerController(target);\r\n            return RootInjector;\r\n        }\r\n\r\n        const routeMeta = getRouteMetadata(target);\r\n\r\n        if(routeMeta) {\r\n            return RootInjector;\r\n        }\r\n\r\n        if(getInjectableMetadata(target)) {\r\n            Logger.log(`Registered ${target.name} as ${lifetime}`);\r\n            return RootInjector;\r\n        }\r\n\r\n        return RootInjector;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Lifetime } from \"src/DI/app-injector\";\r\nimport { InjectorExplorer } from \"src/DI/injector-explorer\";\r\nimport { defineInjectableMetadata } from \"src/decorators/injectable.metadata\";\r\nimport { Type } from \"src/main\";\r\nexport { getInjectableMetadata, hasInjectableMetadata, INJECTABLE_METADATA_KEY } from \"src/decorators/injectable.metadata\";\r\n\r\n/**\r\n * The Injectable decorator marks a class as injectable.\r\n * It allows the class to be registered in the dependency injection system.\r\n * A class decorated with @Injectable can be injected into other classes\r\n * either from the constructor of the class that needs it of from the `inject` function.\r\n * @param lifetime - The lifetime of the injectable. Can be 'singleton', 'scope', or 'transient'.\r\n */\r\nexport function Injectable(lifetime: Lifetime = \"scope\"): ClassDecorator {\r\n    return (target) => {\r\n        if (typeof target !== \"function\" || !target.prototype) {\r\n            throw new Error(`@Injectable can only be used on classes, not on ${typeof target}`);\r\n        }\r\n        defineInjectableMetadata(target, lifetime);\r\n        InjectorExplorer.register(target as unknown as Type<any>, lifetime);\r\n    };\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { getGuardForController, IGuard } from \"src/decorators/guards.decorator\";\r\nimport { Injectable } from \"src/decorators/injectable.decorator\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * The configuration that waits a controller's decorator.\r\n */\r\nexport interface IControllerMetadata {\r\n    path: string;\r\n    guards: Type<IGuard>[];\r\n}\r\n\r\n/**\r\n * Controller decorator is used to define a controller in the application.\r\n * It is a kind of node in the routing tree, that can contains routes and middlewares.\r\n *\r\n * @param path - The path for the controller.\r\n */\r\nexport function Controller(path: string): ClassDecorator {\r\n    return (target) => {\r\n        const data: IControllerMetadata = {\r\n            path,\r\n            guards: getGuardForController(target.name)\r\n        };\r\n\r\n        Reflect.defineMetadata(CONTROLLER_METADATA_KEY, data, target);\r\n        Injectable('scope')(target);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the controller metadata for a given target class.\r\n * This metadata includes the path and guards defined by the @Controller decorator.\r\n * @param target - The target class to get the controller metadata from.\r\n * @returns The controller metadata if it exists, otherwise undefined.\r\n */\r\nexport function getControllerMetadata(target: Type<unknown>): IControllerMetadata | undefined {\r\n    return Reflect.getMetadata(CONTROLLER_METADATA_KEY, target);\r\n}\r\n\r\nexport const CONTROLLER_METADATA_KEY = Symbol('CONTROLLER_METADATA_KEY');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { IResponse, Request } from \"src/request\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { MaybeAsync, Type } from \"src/utils/types\";\r\n\r\n/**\r\n * NextFunction is a function that is called to continue the middleware chain.\r\n * It returns an Promise that emits when the next middleware is done.\r\n */\r\nexport type NextFunction = () => Promise<void>;\r\n\r\n/**\r\n * IMiddleware interface defines a middleware that can be used in the application.\r\n * It has an `invoke` method that takes a request, a response, and a next function.\r\n * The `invoke` method can return a MaybeAsync, which means it can return either a value or a Promise.\r\n *\r\n * Use it on a class that should be registered as a middleware in the application.\r\n */\r\nexport interface IMiddleware {\r\n    invoke(request: Request, response: IResponse, next: NextFunction): MaybeAsync<void>;\r\n}\r\n\r\n/**\r\n * UseMiddlewares decorator can be used to register middlewares for a controller or a controller action.\r\n *\r\n * @param mdlw - The middlewares list to register for the controller or the controller action.\r\n */\r\nexport function UseMiddlewares(mdlw: Type<IMiddleware>[]): ClassDecorator & MethodDecorator {\r\n    return (target: Function | object, propertyKey?: string | symbol) => {\r\n        let key: string;\r\n\r\n        // Method decorator\r\n        if(propertyKey) {\r\n            const ctrlName = target.constructor.name;\r\n            const actionName = propertyKey as string;\r\n            key = `${ctrlName}.${actionName}`;\r\n        }\r\n        // Class decorator\r\n        else {\r\n            const ctrlName = (target as Type<unknown>).name;\r\n            key = `${ctrlName}`;\r\n        }\r\n\r\n        if(middlewares.has(key)) {\r\n            throw new Error(`Middlewares(s) already registered for ${key}`);\r\n        }\r\n\r\n        middlewares.set(key, mdlw);\r\n    };\r\n}\r\n\r\n/**\r\n * Gets the middlewares for a controller or a controller action.\r\n * This function retrieves the middlewares registered with the UseMiddlewares decorator.\r\n * It returns an array of middleware classes that can be used to process requests for the specified controller.\r\n * @param controllerName The name of the controller to get the middlewares for.\r\n * @returns An array of middlewares for the controller.\r\n */\r\nexport function getMiddlewaresForController(controllerName: string): Type<IMiddleware>[] {\r\n    const key = `${controllerName}`;\r\n    return middlewares.get(key) ?? [];\r\n}\r\n\r\n/**\r\n * Gets the middlewares for a controller action.\r\n * This function retrieves the middlewares registered with the UseMiddlewares decorator for a specific action in a controller.\r\n * It returns an array of middleware classes that can be used to process requests for the specified controller action.\r\n * @param controllerName The name of the controller to get the middlewares for.\r\n * @param actionName The name of the action to get the middlewares for.\r\n * @returns An array of middlewares for the controller action.\r\n */\r\nexport function getMiddlewaresForControllerAction(controllerName: string, actionName: string): Type<IMiddleware>[] {\r\n    const key = `${controllerName}.${actionName}`;\r\n    return middlewares.get(key) ?? [];\r\n}\r\n\r\nconst middlewares = new Map<string, Type<IMiddleware>[]>();\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { AtomicHttpMethod, HttpMethod } from 'src/decorators/method.decorator';\r\nimport { AppInjector, RootInjector } from 'src/DI/app-injector';\r\n\r\n/**\r\n * The Request class represents an HTTP request in the Noxus framework.\r\n * It encapsulates the request data, including the event, ID, method, path, and body.\r\n * It also provides a context for dependency injection through the AppInjector.\r\n */\r\nexport class Request {\r\n    public readonly context: AppInjector = RootInjector.createScope();\r\n\r\n    public readonly params: Record<string, string> = {};\r\n\r\n    constructor(\r\n        public readonly event: Electron.MessageEvent,\r\n        public readonly senderId: number,\r\n        public readonly id: string,\r\n        public readonly method: HttpMethod,\r\n        public readonly path: string,\r\n        public readonly body: any,\r\n    ) {\r\n        this.path = path.replace(/^\\/|\\/$/g, '');\r\n    }\r\n}\r\n\r\n/**\r\n * The IRequest interface defines the structure of a request object.\r\n * It includes properties for the sender ID, request ID, path, method, and an optional body.\r\n * This interface is used to standardize the request data across the application.\r\n */\r\nexport interface IRequest<TBody = unknown> {\r\n    senderId: number;\r\n    requestId: string;\r\n    path: string;\r\n    method: HttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestItem<TBody = unknown> {\r\n    requestId?: string;\r\n    path: string;\r\n    method: AtomicHttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestPayload {\r\n    requests: IBatchRequestItem[];\r\n}\r\n\r\n/**\r\n * Creates a Request object from the IPC event data.\r\n * This function extracts the necessary information from the IPC event and constructs a Request instance.\r\n */\r\nexport interface IResponse<TBody = unknown> {\r\n    requestId: string;\r\n    status: number;\r\n    body?: TBody;\r\n    error?: string;\r\n    stack?: string;\r\n}\r\n\r\nexport interface IBatchResponsePayload {\r\n    responses: IResponse[];\r\n}\r\n\r\nexport const RENDERER_EVENT_TYPE = 'noxus:event';\r\n\r\nexport interface IRendererEventMessage<TPayload = unknown> {\r\n    type: typeof RENDERER_EVENT_TYPE;\r\n    event: string;\r\n    payload?: TPayload;\r\n}\r\n\r\nexport function createRendererEventMessage<TPayload = unknown>(event: string, payload?: TPayload): IRendererEventMessage<TPayload> {\r\n    return {\r\n        type: RENDERER_EVENT_TYPE,\r\n        event,\r\n        payload,\r\n    };\r\n}\r\n\r\nexport function isRendererEventMessage(value: unknown): value is IRendererEventMessage {\r\n    if(value === null || typeof value !== 'object') {\r\n        return false;\r\n    }\r\n\r\n    const possibleMessage = value as Partial<IRendererEventMessage>;\r\n\r\n    return possibleMessage.type === RENDERER_EVENT_TYPE && typeof possibleMessage.event === 'string';\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n *\r\n */\r\ntype Params = Record<string, string>;\r\n\r\n/**\r\n * Represents a search result in the Radix Tree.\r\n */\r\ninterface ISearchResult<T> {\r\n    node: RadixNode<T>;\r\n    params: Params;\r\n}\r\n\r\n/**\r\n * Represents a node in the Radix Tree.\r\n * The represents a path segment\r\n */\r\nclass RadixNode<T> {\r\n    public segment: string;\r\n    public children: RadixNode<T>[] = [];\r\n    public value?: T;\r\n    public isParam: boolean;\r\n    public paramName?: string;\r\n\r\n    /**\r\n     * Creates a new RadixNode.\r\n     * @param segment - The segment of the path this node represents.\r\n     */\r\n    constructor(segment: string) {\r\n        this.segment = segment;\r\n        this.isParam = segment.startsWith(\":\");\r\n\r\n        if(this.isParam) {\r\n            this.paramName = segment.slice(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Matches a child node against a given segment.\r\n     * This method checks if the segment matches any of the children nodes.\r\n     * @param segment - The segment to match against the children of this node.\r\n     * @returns A child node that matches the segment, or undefined if no match is found.\r\n     */\r\n    public matchChild(segment: string): RadixNode<T> | undefined {\r\n        for(const child of this.children) {\r\n            if(child.isParam || segment.startsWith(child.segment))\r\n                return child; // param match\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Finds a child node that matches the segment exactly.\r\n     * This method checks if there is a child node that matches the segment exactly.\r\n     * @param segment - The segment to find an exact match for among the children of this node.\r\n     * @returns A child node that matches the segment exactly, or undefined if no match is found.\r\n     */\r\n    public findExactChild(segment: string): RadixNode<T> | undefined {\r\n        return this.children.find(c => c.segment === segment);\r\n    }\r\n\r\n    /**\r\n     * Adds a child node to this node's children.\r\n     * This method adds a new child node to the list of children for this node.\r\n     * @param node - The child node to add to this node's children.\r\n     */\r\n    public addChild(node: RadixNode<T>): void {\r\n        this.children.push(node);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport class RadixTree<T> {\r\n    private readonly root = new RadixNode<T>(\"\");\r\n\r\n    /**\r\n     * Inserts a path and its associated value into the Radix Tree.\r\n     * This method normalizes the path and inserts it into the tree, associating it with\r\n     * @param path - The path to insert into the tree.\r\n     * @param value - The value to associate with the path.\r\n     */\r\n    public insert(path: string, value: T): void {\r\n        const segments = this.normalize(path);\r\n        this.insertRecursive(this.root, segments, value);\r\n    }\r\n\r\n    /**\r\n     * Recursively inserts a path into the Radix Tree.\r\n     * This method traverses the tree and inserts the segments of the path, creating new nodes\r\n     * @param node - The node to start inserting from.\r\n     * @param segments - The segments of the path to insert.\r\n     * @param value - The value to associate with the path.\r\n     */\r\n    private insertRecursive(node: RadixNode<T>, segments: string[], value: T): void {\r\n        if(segments.length === 0) {\r\n            node.value = value;\r\n            return;\r\n        }\r\n\r\n        const segment = segments[0] ?? \"\";\r\n\r\n        let child = node.children.find(c =>\r\n            c.isParam === segment.startsWith(\":\") &&\r\n            (c.isParam || c.segment === segment)\r\n        );\r\n\r\n        if(!child) {\r\n            child = new RadixNode<T>(segment);\r\n            node.addChild(child);\r\n        }\r\n\r\n        this.insertRecursive(child, segments.slice(1), value);\r\n    }\r\n\r\n    /**\r\n     * Searches for a path in the Radix Tree.\r\n     * This method normalizes the path and searches for it in the tree, returning the node\r\n     * @param path - The path to search for in the Radix Tree.\r\n     * @returns An ISearchResult containing the node and parameters if a match is found, otherwise undefined.\r\n     */\r\n    public search(path: string): ISearchResult<T> | undefined {\r\n        const segments = this.normalize(path);\r\n        return this.searchRecursive(this.root, segments, {});\r\n    }\r\n\r\n    /**\r\n     * Recursively searches for a path in the Radix Tree.\r\n     * This method traverses the tree and searches for the segments of the path, collecting parameters\r\n     * @param node - The node to start searching from.\r\n     * @param segments - The segments of the path to search for.\r\n     * @param params - The parameters collected during the search.\r\n     * @returns An ISearchResult containing the node and parameters if a match is found, otherwise undefined.\r\n     */\r\n    private searchRecursive(node: RadixNode<T>, segments: string[], params: Params): ISearchResult<T> | undefined {\r\n        if(segments.length === 0) {\r\n            if(node.value !== undefined) {\r\n                return {\r\n                    node: node,\r\n                    params\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        const [segment, ...rest] = segments;\r\n\r\n        for(const child of node.children) {\r\n            if(child.isParam) {\r\n                const paramName = child.paramName!;\r\n\r\n                const childParams: Params = {\r\n                    ...params,\r\n                    [paramName]: segment ?? \"\",\r\n                };\r\n\r\n                if(rest.length === 0) {\r\n                    return {\r\n                        node: child,\r\n                        params: childParams\r\n                    };\r\n                }\r\n\r\n                const result = this.searchRecursive(child, rest, childParams);\r\n\r\n                if(result)\r\n                    return result;\r\n            }\r\n            else if(segment === child.segment) {\r\n                if(rest.length === 0) {\r\n                    return {\r\n                        node: child,\r\n                        params\r\n                    };\r\n                }\r\n\r\n                const result = this.searchRecursive(child, rest, params);\r\n\r\n                if(result)\r\n                    return result;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Normalizes a path into an array of segments.\r\n     * This method removes leading and trailing slashes, splits the path by slashes, and\r\n     * @param path - The path to normalize.\r\n     * @returns An array of normalized path segments.\r\n     */\r\n    private normalize(path: string): string[] {\r\n        const segments = path\r\n            .replace(/^\\/+|\\/+$/g, \"\")\r\n            .split(\"/\")\r\n            .filter(Boolean);\r\n\r\n        return ['', ...segments];\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { app, BrowserWindow, ipcMain, MessageChannelMain } from \"electron/main\";\r\nimport { Injectable } from \"src/decorators/injectable.decorator\";\r\nimport { IMiddleware } from \"src/decorators/middleware.decorator\";\r\nimport { inject } from \"src/DI/app-injector\";\r\nimport { IRequest, IResponse, Request } from \"src/request\";\r\nimport { NoxSocket } from \"src/socket\";\r\nimport { Router } from \"src/router\";\r\nimport { Logger } from \"src/utils/logger\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * The application service should implement this interface, as\r\n * the NoxApp class instance will use it to notify the given service\r\n * about application lifecycle events.\r\n */\r\nexport interface IApp {\r\n    dispose(): Promise<void>;\r\n    onReady(): Promise<void>;\r\n    onActivated(): Promise<void>;\r\n}\r\n\r\n/**\r\n * NoxApp is the main application class that manages the application lifecycle,\r\n * handles IPC communication, and integrates with the Router.\r\n */\r\n@Injectable('singleton')\r\nexport class NoxApp {\r\n    private app: IApp | undefined;\r\n\r\n    /**\r\n     *\r\n     */\r\n    private readonly onRendererMessage = async (event: Electron.MessageEvent): Promise<void> => {\r\n        const { senderId, requestId, path, method, body }: IRequest = event.data;\r\n\r\n        const channels = this.socket.get(senderId);\r\n\r\n        if(!channels) {\r\n            Logger.error(`No message channel found for sender ID: ${senderId}`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const request = new Request(event, senderId, requestId, method, path, body);\r\n            const response = await this.router.handle(request);\r\n            channels.request.port1.postMessage(response);\r\n        }\r\n        catch(err: any) {\r\n            const response: IResponse = {\r\n                requestId,\r\n                status: 500,\r\n                body: null,\r\n                error: err.message || 'Internal Server Error',\r\n            };\r\n\r\n            channels.request.port1.postMessage(response);\r\n        }\r\n    };\r\n\r\n    constructor(\r\n        private readonly router: Router,\r\n        private readonly socket: NoxSocket,\r\n    ) {}\r\n\r\n    /**\r\n     * Initializes the NoxApp instance.\r\n     * This method sets up the IPC communication, registers event listeners,\r\n     * and prepares the application for use.\r\n     */\r\n    public async init(): Promise<NoxApp> {\r\n        ipcMain.on('gimme-my-port', this.giveTheRendererAPort.bind(this));\r\n\r\n        app.once('activate', this.onAppActivated.bind(this));\r\n        app.once('window-all-closed', this.onAllWindowsClosed.bind(this));\r\n\r\n        console.log(''); // create a new line in the console to separate setup logs from the future logs\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Handles the request from the renderer process.\r\n     * This method creates a Request object from the IPC event data,\r\n     * processes it through the Router, and sends the response back\r\n     * to the renderer process using the MessageChannel.\r\n     */\r\n    private giveTheRendererAPort(event: Electron.IpcMainInvokeEvent): void {\r\n        const senderId = event.sender.id;\r\n\r\n        if(this.socket.get(senderId)) {\r\n            this.shutdownChannel(senderId);\r\n        }\r\n\r\n        const requestChannel = new MessageChannelMain();\r\n        const socketChannel = new MessageChannelMain();\r\n\r\n        requestChannel.port1.on('message', this.onRendererMessage);\r\n        requestChannel.port1.start();\r\n        socketChannel.port1.start();\r\n\r\n        this.socket.register(senderId, requestChannel, socketChannel);\r\n\r\n        event.sender.postMessage('port', { senderId }, [requestChannel.port2, socketChannel.port2]);\r\n    }\r\n\r\n    /**\r\n     * MacOS specific behavior.\r\n     */\r\n    private onAppActivated(): void {\r\n        if(process.platform === 'darwin' && BrowserWindow.getAllWindows().length === 0) {\r\n            this.app?.onActivated();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shuts down the message channel for a specific sender ID.\r\n     * This method closes the IPC channel for the specified sender ID and\r\n     * removes it from the messagePorts map.\r\n     * @param channelSenderId - The ID of the sender channel to shut down.\r\n     * @param remove - Whether to remove the channel from the messagePorts map.\r\n     */\r\n    private shutdownChannel(channelSenderId: number): void {\r\n        const channels = this.socket.get(channelSenderId);\r\n\r\n        if(!channels) {\r\n            Logger.warn(`No message channel found for sender ID: ${channelSenderId}`);\r\n            return;\r\n        }\r\n\r\n        channels.request.port1.off('message', this.onRendererMessage);\r\n        channels.request.port1.close();\r\n        channels.request.port2.close();\r\n\r\n        channels.socket.port1.close();\r\n        channels.socket.port2.close();\r\n\r\n        this.socket.unregister(channelSenderId);\r\n    }\r\n\r\n    /**\r\n     * Handles the application shutdown process.\r\n     * This method is called when all windows are closed, and it cleans up the message channels\r\n     */\r\n    private async onAllWindowsClosed(): Promise<void> {\r\n        for(const senderId of this.socket.getSenderIds()) {\r\n            this.shutdownChannel(senderId);\r\n        }\r\n\r\n        Logger.info('All windows closed, shutting down application...');\r\n        await this.app?.dispose();\r\n\r\n        if(process.platform !== 'darwin') {\r\n            app.quit();\r\n        }\r\n    }\r\n\r\n\r\n    // ---\r\n\r\n    /**\r\n     * Configures the NoxApp instance with the provided application class.\r\n     * This method allows you to set the application class that will handle lifecycle events.\r\n     * @param app - The application class to configure.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public configure(app: Type<IApp>): NoxApp {\r\n        this.app = inject(app);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers a middleware for the root of the application.\r\n     * This method allows you to define a middleware that will be applied to all requests\r\n     * @param middleware - The middleware class to register.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public use(middleware: Type<IMiddleware>): NoxApp {\r\n        this.router.defineRootMiddleware(middleware);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Should be called after the bootstrapApplication function is called.\r\n     * @returns NoxApp instance for method chaining.\r\n     */\r\n    public start(): NoxApp {\r\n        this.app?.onReady();\r\n        return this;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Centralizes MessagePort storage for renderer communication and handles\r\n * push-event delivery back to renderer processes.\r\n */\r\nimport { Injectable } from 'src/decorators/injectable.decorator';\r\nimport { createRendererEventMessage } from 'src/request';\r\nimport { Logger } from 'src/utils/logger';\r\n\r\ninterface RendererChannels {\r\n    request: Electron.MessageChannelMain;\r\n    socket: Electron.MessageChannelMain;\r\n}\r\n\r\n@Injectable('singleton')\r\nexport class NoxSocket {\r\n    private readonly channels = new Map<number, RendererChannels>();\r\n\r\n    public register(senderId: number, requestChannel: Electron.MessageChannelMain, socketChannel: Electron.MessageChannelMain): void {\r\n        this.channels.set(senderId, { request: requestChannel, socket: socketChannel });\r\n    }\r\n\r\n    public get(senderId: number): RendererChannels | undefined {\r\n        return this.channels.get(senderId);\r\n    }\r\n\r\n    public unregister(senderId: number): void {\r\n        this.channels.delete(senderId);\r\n    }\r\n\r\n    public getSenderIds(): number[] {\r\n        return [...this.channels.keys()];\r\n    }\r\n\r\n    public emit<TPayload = unknown>(eventName: string, payload?: TPayload, targetSenderIds?: number[]): number {\r\n        const normalizedEvent = eventName.trim();\r\n\r\n        if(normalizedEvent.length === 0) {\r\n            throw new Error('Renderer event name must be a non-empty string.');\r\n        }\r\n\r\n        const recipients = targetSenderIds ?? this.getSenderIds();\r\n        let delivered = 0;\r\n\r\n        for(const senderId of recipients) {\r\n            const channel = this.channels.get(senderId);\r\n\r\n            if(!channel) {\r\n                Logger.warn(`No message channel found for sender ID: ${senderId} while emitting \"${normalizedEvent}\".`);\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                channel.socket.port1.postMessage(createRendererEventMessage(normalizedEvent, payload));\r\n                delivered++;\r\n            }\r\n            catch(error) {\r\n                Logger.error(`[Noxus] Failed to emit \"${normalizedEvent}\" to sender ${senderId}.`, error);\r\n            }\r\n        }\r\n\r\n        return delivered;\r\n    }\r\n\r\n    public emitToRenderer<TPayload = unknown>(senderId: number, eventName: string, payload?: TPayload): boolean {\r\n        return this.emit(eventName, payload, [senderId]) > 0;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { app } from \"electron/main\";\r\nimport { NoxApp } from \"src/app\";\r\nimport { getModuleMetadata } from \"src/decorators/module.decorator\";\r\nimport { inject } from \"src/DI/app-injector\";\r\nimport { Type } from \"src/utils/types\";\r\n\r\n/**\r\n * Bootstraps the Noxus application.\r\n * This function initializes the application by creating an instance of NoxApp,\r\n * registering the root module, and starting the application.\r\n * @param rootModule - The root module of the application, decorated with @Module.\r\n * @return A promise that resolves to the NoxApp instance.\r\n * @throws Error if the root module is not decorated with @Module, or if the electron process could not start.\r\n */\r\nexport async function bootstrapApplication(rootModule: Type<any>): Promise<NoxApp> {\r\n    if(!getModuleMetadata(rootModule)) {\r\n        throw new Error(`Root module must be decorated with @Module`);\r\n    }\r\n\r\n    await app.whenReady();\r\n\r\n    const noxApp = inject(NoxApp);\r\n\r\n    await noxApp.init();\r\n\r\n    return noxApp;\r\n}\r\n\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { contextBridge, ipcRenderer } from 'electron/renderer';\r\nimport type { IPortRequester } from 'src/renderer-client';\r\n\r\nexport interface NoxusPreloadAPI extends IPortRequester {}\r\n\r\nexport interface NoxusPreloadOptions {\r\n    exposeAs?: string;\r\n    initMessageType?: string;\r\n    requestChannel?: string;\r\n    responseChannel?: string;\r\n    targetWindow?: Window;\r\n}\r\n\r\nconst DEFAULT_EXPOSE_NAME = 'noxus';\r\nconst DEFAULT_INIT_EVENT = 'init-port';\r\nconst DEFAULT_REQUEST_CHANNEL = 'gimme-my-port';\r\nconst DEFAULT_RESPONSE_CHANNEL = 'port';\r\n\r\n/**\r\n * Exposes a minimal bridge in the isolated preload context so renderer processes\r\n * can request the two MessagePorts required by Noxus. The bridge forwards both\r\n * request/response and socket ports to the renderer via window.postMessage.\r\n */\r\nexport function exposeNoxusBridge(options: NoxusPreloadOptions = {}): NoxusPreloadAPI {\r\n    const {\r\n        exposeAs = DEFAULT_EXPOSE_NAME,\r\n        initMessageType = DEFAULT_INIT_EVENT,\r\n        requestChannel = DEFAULT_REQUEST_CHANNEL,\r\n        responseChannel = DEFAULT_RESPONSE_CHANNEL,\r\n        targetWindow = window,\r\n    } = options;\r\n\r\n    const api: NoxusPreloadAPI = {\r\n        requestPort: () => {\r\n            ipcRenderer.send(requestChannel);\r\n\r\n            ipcRenderer.once(responseChannel, (event, message: { senderId: number }) => {\r\n                const ports = (event.ports ?? []).filter((port): port is MessagePort => port !== undefined);\r\n\r\n                if(ports.length === 0) {\r\n                    console.error('[Noxus] No MessagePort received from main process.');\r\n                    return;\r\n                }\r\n\r\n                for(const port of ports) {\r\n                    try {\r\n                        port.start();\r\n                    }\r\n                    catch(error) {\r\n                        console.error('[Noxus] Failed to start MessagePort.', error);\r\n                    }\r\n                }\r\n\r\n                targetWindow.postMessage(\r\n                    {\r\n                        type: initMessageType,\r\n                        senderId: message?.senderId,\r\n                    },\r\n                    '*',\r\n                    ports,\r\n                );\r\n            });\r\n        },\r\n    };\r\n\r\n    contextBridge.exposeInMainWorld(exposeAs, api);\r\n\r\n    return api;\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Lightweight event registry to help renderer processes subscribe to\r\n * push messages sent by the main process through Noxus.\r\n */\r\nimport { IRendererEventMessage, isRendererEventMessage } from 'src/request';\r\n\r\nexport type RendererEventHandler<TPayload = unknown> = (payload: TPayload) => void;\r\n\r\nexport interface RendererEventSubscription {\r\n    unsubscribe(): void;\r\n}\r\n\r\nexport class RendererEventRegistry {\r\n    private readonly listeners = new Map<string, Set<RendererEventHandler>>();\r\n\r\n    /**\r\n     *\r\n     */\r\n    public subscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): RendererEventSubscription {\r\n        const normalizedEventName = eventName.trim();\r\n\r\n        if(normalizedEventName.length === 0) {\r\n            throw new Error('Renderer event name must be a non-empty string.');\r\n        }\r\n\r\n        const handlers = this.listeners.get(normalizedEventName) ?? new Set<RendererEventHandler>();\r\n\r\n        handlers.add(handler as RendererEventHandler);\r\n        this.listeners.set(normalizedEventName, handlers);\r\n\r\n        return {\r\n            unsubscribe: () => this.unsubscribe(normalizedEventName, handler as RendererEventHandler),\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public unsubscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): void {\r\n        const handlers = this.listeners.get(eventName);\r\n\r\n        if(!handlers) {\r\n            return;\r\n        }\r\n\r\n        handlers.delete(handler as RendererEventHandler);\r\n\r\n        if(handlers.size === 0) {\r\n            this.listeners.delete(eventName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public clear(eventName?: string): void {\r\n        if(eventName) {\r\n            this.listeners.delete(eventName);\r\n            return;\r\n        }\r\n\r\n        this.listeners.clear();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public dispatch<TPayload>(message: IRendererEventMessage<TPayload>): void {\r\n        const handlers = this.listeners.get(message.event);\r\n\r\n        if(!handlers || handlers.size === 0) {\r\n            return;\r\n        }\r\n\r\n        handlers.forEach((handler) => {\r\n            try {\r\n                handler(message.payload as TPayload);\r\n            }\r\n            catch(error) {\r\n                console.error(`[Noxus] Renderer event handler for \"${message.event}\" threw an error.`, error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public tryDispatchFromMessageEvent(event: MessageEvent): boolean {\r\n        if(!isRendererEventMessage(event.data)) {\r\n            return false;\r\n        }\r\n\r\n        this.dispatch(event.data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public hasHandlers(eventName: string): boolean {\r\n        const handlers = this.listeners.get(eventName);\r\n        return !!handlers && handlers.size > 0;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { IBatchRequestItem, IBatchResponsePayload, IRequest, IResponse } from 'src/request';\r\nimport { RendererEventRegistry } from 'src/renderer-events';\r\n\r\nexport interface IPortRequester {\r\n    requestPort(): void;\r\n}\r\n\r\nexport interface RendererClientOptions {\r\n    bridge?: IPortRequester | null;\r\n    bridgeName?: string | string[];\r\n    initMessageType?: string;\r\n    windowRef?: Window;\r\n    generateRequestId?: () => string;\r\n}\r\n\r\ninterface PendingRequest<T = unknown> {\r\n    resolve: (value: T) => void;\r\n    reject: (reason: IResponse<T>) => void;\r\n    request: IRequest;\r\n    submittedAt: number;\r\n}\r\n\r\nconst DEFAULT_INIT_EVENT = 'init-port';\r\nconst DEFAULT_BRIDGE_NAMES = ['noxus', 'ipcRenderer'];\r\n\r\nfunction defaultRequestId(): string {\r\n    if(typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\r\n        return crypto.randomUUID();\r\n    }\r\n\r\n    return `${Date.now().toString(16)}-${Math.floor(Math.random() * 1e8).toString(16)}`;\r\n}\r\n\r\nfunction normalizeBridgeNames(preferred?: string | string[]): string[] {\r\n    const names: string[] = [];\r\n\r\n    const add = (name: string | undefined): void => {\r\n        if(!name)\r\n            return;\r\n\r\n        if(!names.includes(name)) {\r\n            names.push(name);\r\n        }\r\n    };\r\n\r\n    if(Array.isArray(preferred)) {\r\n        for(const name of preferred) {\r\n            add(name);\r\n        }\r\n    }\r\n    else {\r\n        add(preferred);\r\n    }\r\n\r\n    for(const fallback of DEFAULT_BRIDGE_NAMES) {\r\n        add(fallback);\r\n    }\r\n\r\n    return names;\r\n}\r\n\r\nfunction resolveBridgeFromWindow(windowRef: Window, preferred?: string | string[]): IPortRequester | null {\r\n    const names = normalizeBridgeNames(preferred);\r\n    const globalRef = windowRef as unknown as Record<string, unknown> | null | undefined;\r\n\r\n    if(!globalRef) {\r\n        return null;\r\n    }\r\n\r\n    for(const name of names) {\r\n        const candidate = globalRef[name];\r\n\r\n        if(candidate && typeof (candidate as IPortRequester).requestPort === 'function') {\r\n            return candidate as IPortRequester;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport class NoxRendererClient {\r\n    public readonly events = new RendererEventRegistry();\r\n\r\n    protected readonly pendingRequests = new Map<string, PendingRequest>();\r\n\r\n    protected requestPort: MessagePort | undefined;\r\n    protected socketPort: MessagePort | undefined;\r\n    protected senderId: number | undefined;\r\n\r\n    private readonly bridge: IPortRequester | null;\r\n    private readonly initMessageType: string;\r\n    private readonly windowRef: Window;\r\n    private readonly generateRequestId: () => string;\r\n\r\n    private isReady = false;\r\n    private setupPromise: Promise<void> | undefined;\r\n    private setupResolve: (() => void) | undefined;\r\n    private setupReject: ((reason: Error) => void) | undefined;\r\n\r\n    constructor(options: RendererClientOptions = {}) {\r\n        this.windowRef = options.windowRef ?? window;\r\n        const resolvedBridge = options.bridge ?? resolveBridgeFromWindow(this.windowRef, options.bridgeName);\r\n        this.bridge = resolvedBridge ?? null;\r\n        this.initMessageType = options.initMessageType ?? DEFAULT_INIT_EVENT;\r\n        this.generateRequestId = options.generateRequestId ?? defaultRequestId;\r\n    }\r\n\r\n    public async setup(): Promise<void> {\r\n        if(this.isReady) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if(this.setupPromise) {\r\n            return this.setupPromise;\r\n        }\r\n\r\n        if(!this.bridge || typeof this.bridge.requestPort !== 'function') {\r\n            throw new Error('[Noxus] Renderer bridge is missing requestPort().');\r\n        }\r\n\r\n        this.setupPromise = new Promise<void>((resolve, reject) => {\r\n            this.setupResolve = resolve;\r\n            this.setupReject = reject;\r\n        });\r\n\r\n        this.windowRef.addEventListener('message', this.onWindowMessage);\r\n        this.bridge.requestPort();\r\n\r\n        return this.setupPromise;\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort?.close();\r\n        this.socketPort?.close();\r\n\r\n        this.requestPort = undefined;\r\n        this.socketPort = undefined;\r\n        this.senderId = undefined;\r\n        this.isReady = false;\r\n\r\n        this.pendingRequests.clear();\r\n    }\r\n\r\n    public async request<TResponse, TBody = unknown>(request: Omit<IRequest<TBody>, 'requestId' | 'senderId'>): Promise<TResponse> {\r\n        const senderId = this.senderId;\r\n        const requestId = this.generateRequestId();\r\n\r\n        if(senderId === undefined) {\r\n            return Promise.reject(this.createErrorResponse(requestId, 'MessagePort is not available'));\r\n        }\r\n\r\n        const readinessError = this.validateReady(requestId);\r\n\r\n        if(readinessError) {\r\n            return Promise.reject(readinessError as IResponse<TResponse>);\r\n        }\r\n\r\n        const message: IRequest<TBody> = {\r\n            requestId,\r\n            senderId,\r\n            ...request,\r\n        };\r\n\r\n        return new Promise<TResponse>((resolve, reject) => {\r\n            const pending: PendingRequest<TResponse> = {\r\n                resolve,\r\n                reject: (response: IResponse<TResponse>) => reject(response),\r\n                request: message,\r\n                submittedAt: Date.now(),\r\n            };\r\n\r\n            this.pendingRequests.set(message.requestId, pending as PendingRequest);\r\n\r\n            this.requestPort!.postMessage(message);\r\n        });\r\n    }\r\n\r\n    public async batch(requests: Omit<IBatchRequestItem<unknown>, 'requestId'>[]): Promise<IBatchResponsePayload> {\r\n        return this.request<IBatchResponsePayload>({\r\n            method: 'BATCH',\r\n            path: '',\r\n            body: {\r\n                requests,\r\n            },\r\n        });\r\n    }\r\n\r\n    public getSenderId(): number | undefined {\r\n        return this.senderId;\r\n    }\r\n\r\n    private readonly onWindowMessage = (event: MessageEvent): void => {\r\n        if(event.data?.type !== this.initMessageType) {\r\n            return;\r\n        }\r\n\r\n        if(!Array.isArray(event.ports) || event.ports.length < 2) {\r\n            const error = new Error('[Noxus] Renderer expected two MessagePorts (request + socket).');\r\n\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort = event.ports[0];\r\n        this.socketPort = event.ports[1];\r\n        this.senderId = event.data.senderId;\r\n\r\n        if(this.requestPort === undefined || this.socketPort === undefined) {\r\n            const error = new Error('[Noxus] Renderer failed to receive valid MessagePorts.');\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.attachRequestPort(this.requestPort);\r\n        this.attachSocketPort(this.socketPort);\r\n\r\n        this.isReady = true;\r\n        this.setupResolve?.();\r\n        this.resetSetupState(true);\r\n    };\r\n\r\n    private readonly onSocketMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        console.warn('[Noxus] Received a socket message that is not a renderer event payload.', event.data);\r\n    };\r\n\r\n    private readonly onRequestMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        const response: IResponse = event.data;\r\n\r\n        if(!response || typeof response.requestId !== 'string') {\r\n            console.error('[Noxus] Renderer received an invalid response payload.', response);\r\n            return;\r\n        }\r\n\r\n        const pending = this.pendingRequests.get(response.requestId);\r\n\r\n        if(!pending) {\r\n            console.error(`[Noxus] No pending handler found for request ${response.requestId}.`);\r\n            return;\r\n        }\r\n\r\n        this.pendingRequests.delete(response.requestId);\r\n\r\n        this.onRequestCompleted(pending, response);\r\n\r\n        if(response.status >= 400) {\r\n            pending.reject(response as IResponse<any>);\r\n            return;\r\n        }\r\n\r\n        pending.resolve(response.body as unknown);\r\n    };\r\n\r\n    protected onRequestCompleted(pending: PendingRequest, response: IResponse): void {\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupCollapsed(`${response.status} ${pending.request.method} /${pending.request.path}`);\r\n        }\r\n\r\n        if(response.error) {\r\n            console.error('error message:', response.error);\r\n        }\r\n\r\n        if(response.body !== undefined) {\r\n            console.info('response:', response.body);\r\n        }\r\n\r\n        console.info('request:', pending.request);\r\n        console.info(`Request duration: ${Date.now() - pending.submittedAt} ms`);\r\n\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupEnd();\r\n        }\r\n    }\r\n\r\n    private attachRequestPort(port: MessagePort): void {\r\n        port.onmessage = this.onRequestMessage;\r\n        port.start();\r\n    }\r\n\r\n    private attachSocketPort(port: MessagePort): void {\r\n        port.onmessage = this.onSocketMessage;\r\n        port.start();\r\n    }\r\n\r\n    private validateReady(requestId: string): IResponse | undefined {\r\n        if(!this.isElectronEnvironment()) {\r\n            return this.createErrorResponse(requestId, 'Not running in Electron environment');\r\n        }\r\n\r\n        if(!this.requestPort) {\r\n            return this.createErrorResponse(requestId, 'MessagePort is not available');\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private createErrorResponse<T>(requestId: string, message: string): IResponse<T> {\r\n        return {\r\n            status: 500,\r\n            requestId,\r\n            error: message,\r\n        };\r\n    }\r\n\r\n    private resetSetupState(success = false): void {\r\n        if(!success) {\r\n            this.setupPromise = undefined;\r\n        }\r\n\r\n        this.setupResolve = undefined;\r\n        this.setupReject = undefined;\r\n    }\r\n\r\n    public isElectronEnvironment(): boolean {\r\n        return typeof window !== 'undefined' && /Electron/.test(window.navigator.userAgent);\r\n    }\r\n}\r\n"],"mappings":"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","names":["INJECT_METADATA_KEY","Inject","token","target","propertyKey","parameterIndex","existingParameters","Reflect","getOwnMetadata","defineMetadata","ResponseException","Error","statusOrMessage","message","statusCode","status","undefined","name","replace","BadRequestException","UnauthorizedException","PaymentRequiredException","ForbiddenException","NotFoundException","MethodNotAllowedException","NotAcceptableException","RequestTimeoutException","ConflictException","UpgradeRequiredException","TooManyRequestsException","InternalServerException","NotImplementedException","BadGatewayException","ServiceUnavailableException","GatewayTimeoutException","HttpVersionNotSupportedException","VariantAlsoNegotiatesException","InsufficientStorageException","LoopDetectedException","NotExtendedException","NetworkAuthenticationRequiredException","NetworkConnectTimeoutException","ForwardReference","forwardRefFn","forwardRef","fn","AppInjector","name","bindings","Map","singletons","scoped","createScope","scope","resolve","target","ForwardReference","Proxy","get","obj","prop","receiver","realType","forwardRefFn","instance","value","Reflect","bind","set","getPrototypeOf","prototype","binding","undefined","InternalServerException","lifetime","instantiate","implementation","has","paramTypes","getMetadata","injectParams","INJECT_METADATA_KEY","params","map","paramType","index","overrideToken","actualToken","inject","t","RootInjector","Authorize","guardClasses","target","propertyKey","key","ctrlName","name","actionName","authorizations","has","Error","set","getGuardForController","controllerName","get","getGuardForControllerAction","Map","INJECTABLE_METADATA_KEY","Symbol","defineInjectableMetadata","target","lifetime","Reflect","defineMetadata","getInjectableMetadata","getMetadata","hasInjectableMetadata","hasMetadata","createRouteDecorator","verb","path","target","propertyKey","existingRoutes","Reflect","getMetadata","ROUTE_METADATA_KEY","metadata","method","trim","replace","handler","guards","getGuardForControllerAction","__controllerName","push","defineMetadata","getRouteMetadata","Get","Post","Put","Patch","Delete","Symbol","Module","metadata","target","checkModule","arr","arrName","clazz","Reflect","getMetadata","MODULE_METADATA_KEY","Error","name","checkInjectable","INJECTABLE_METADATA_KEY","checkController","CONTROLLER_METADATA_KEY","imports","exports","providers","controllers","defineMetadata","Injectable","getModuleMetadata","Symbol","fs","path","getPrettyTimestamp","now","Date","getDate","toString","padStart","getMonth","getFullYear","getHours","getMinutes","getSeconds","getLogPrefix","callee","messageType","color","timestamp","spaces","repeat","length","colReset","Logger","colors","initial","colCallee","yellow","undefined","process","pid","toUpperCase","formatObject","prefix","arg","enableColor","json","JSON","stringify","colStart","colLine","darkGrey","grey","prefixedJson","split","map","line","idx","join","formattedArgs","args","getCallee","stack","Error","caller","trim","match","replace","canLog","level","logLevels","has","processLogQueue","filepath","state","fileStates","get","isWriting","queue","messagesToWrite","dir","dirname","fs","mkdir","recursive","err","console","error","appendFile","encoding","enqueue","message","set","push","output","logLevelColors","data","logLevelChannel","fileSettings","setLogLevel","clear","Array","isArray","lvl","add","targetRank","logLevelRank","rank","Object","entries","log","info","warn","errorStack","debug","comment","critical","enableFileLogging","levels","disableFileLogging","delete","black","red","green","brown","blue","purple","lightRed","lightGreen","lightBlue","magenta","cyan","white","Map","Set","InjectorExplorer","register","target","lifetime","RootInjector","bindings","has","set","implementation","resolve","getModuleMetadata","Logger","log","name","controllerMeta","getControllerMetadata","router","Router","registerController","routeMeta","getRouteMetadata","getInjectableMetadata","Injectable","lifetime","target","prototype","Error","defineInjectableMetadata","InjectorExplorer","register","Controller","path","target","data","guards","getGuardForController","name","Reflect","defineMetadata","CONTROLLER_METADATA_KEY","Injectable","getControllerMetadata","getMetadata","Symbol","UseMiddlewares","mdlw","target","propertyKey","key","ctrlName","name","actionName","middlewares","has","Error","set","getMiddlewaresForController","controllerName","get","getMiddlewaresForControllerAction","Map","Request","event","senderId","id","method","path","body","context","RootInjector","createScope","params","replace","RENDERER_EVENT_TYPE","createRendererEventMessage","payload","type","isRendererEventMessage","value","possibleMessage","RadixNode","segment","children","value","isParam","paramName","startsWith","slice","matchChild","child","undefined","findExactChild","find","c","addChild","node","push","RadixTree","root","insert","path","segments","normalize","insertRecursive","length","search","searchRecursive","params","rest","childParams","result","replace","split","filter","Boolean","ATOMIC_HTTP_METHODS","Set","isAtomicHttpMethod","method","has","Router","routes","RadixTree","rootMiddlewares","registerController","controllerClass","controllerMeta","getControllerMetadata","controllerGuards","getGuardForController","name","controllerMiddlewares","getMiddlewaresForController","Error","routeMetadata","getRouteMetadata","def","fullPath","path","replace","routeGuards","getGuardForControllerAction","handler","routeMiddlewares","getMiddlewaresForControllerAction","guards","middlewares","routeDef","controller","insert","hasActionGuards","length","actionGuardsInfo","map","g","join","Logger","log","hasCtrlGuards","controllerGuardsInfo","defineRootMiddleware","middleware","push","handle","request","handleBatch","handleAtomic","comment","t0","performance","now","response","requestId","id","status","body","isCritical","findRoute","resolveController","ResponseException","error","undefined","message","stack","t1","colors","yellow","Math","round","initial","warn","critical","errorStack","responses","payload","normalizeBatchPayload","batchResponses","index","item","requests","entries","subRequestId","atomicRequest","Request","event","senderId","BadRequestException","possiblePayload","Array","isArray","normalizedRequests","entry","normalizeBatchItem","normalizedMethod","toUpperCase","matchedRoutes","search","node","children","NotFoundException","findExactChild","value","MethodNotAllowedException","controllerInstance","context","resolve","Object","assign","params","extractParams","runRequestPipeline","middlewareMaxIndex","guardsMaxIndex","dispatch","i","nextFn","bind","runMiddleware","guardIndex","guardType","runGuard","action","call","next","middlewareType","invoke","guard","allowed","canActivate","UnauthorizedException","actual","template","aParts","split","tParts","forEach","part","startsWith","slice","app","BrowserWindow","ipcMain","MessageChannelMain","_ts_decorate","NoxSocket","channels","Map","register","senderId","requestChannel","socketChannel","set","request","socket","get","unregister","delete","getSenderIds","keys","emit","eventName","payload","targetSenderIds","normalizedEvent","trim","length","Error","recipients","delivered","channel","Logger","warn","port1","postMessage","createRendererEventMessage","error","emitToRenderer","_ts_decorate","NoxApp","router","socket","app","onRendererMessage","event","senderId","requestId","path","method","body","data","channels","get","Logger","error","request","Request","response","handle","port1","postMessage","err","status","message","init","ipcMain","on","giveTheRendererAPort","bind","once","onAppActivated","onAllWindowsClosed","console","log","sender","id","shutdownChannel","requestChannel","MessageChannelMain","socketChannel","start","register","port2","process","platform","BrowserWindow","getAllWindows","length","onActivated","channelSenderId","warn","off","close","unregister","getSenderIds","info","dispose","quit","configure","inject","use","middleware","defineRootMiddleware","onReady","app","bootstrapApplication","rootModule","getModuleMetadata","Error","app","whenReady","noxApp","inject","NoxApp","init","contextBridge","ipcRenderer","DEFAULT_EXPOSE_NAME","DEFAULT_INIT_EVENT","DEFAULT_REQUEST_CHANNEL","DEFAULT_RESPONSE_CHANNEL","exposeNoxusBridge","options","exposeAs","initMessageType","requestChannel","responseChannel","targetWindow","window","api","requestPort","ipcRenderer","send","once","event","message","ports","filter","port","undefined","length","console","error","start","postMessage","type","senderId","contextBridge","exposeInMainWorld","RendererEventRegistry","listeners","Map","subscribe","eventName","handler","normalizedEventName","trim","length","Error","handlers","get","Set","add","set","unsubscribe","delete","size","clear","dispatch","message","event","forEach","payload","error","console","tryDispatchFromMessageEvent","isRendererEventMessage","data","hasHandlers","DEFAULT_INIT_EVENT","DEFAULT_BRIDGE_NAMES","defaultRequestId","crypto","randomUUID","Date","now","toString","Math","floor","random","normalizeBridgeNames","preferred","names","add","name","includes","push","Array","isArray","fallback","resolveBridgeFromWindow","windowRef","globalRef","candidate","requestPort","NoxRendererClient","options","events","RendererEventRegistry","pendingRequests","Map","socketPort","senderId","bridge","initMessageType","generateRequestId","isReady","setupPromise","setupResolve","setupReject","onWindowMessage","event","data","type","ports","length","error","Error","console","resetSetupState","removeEventListener","undefined","attachRequestPort","attachSocketPort","onSocketMessage","tryDispatchFromMessageEvent","warn","onRequestMessage","response","requestId","pending","get","delete","onRequestCompleted","status","reject","resolve","body","window","resolvedBridge","bridgeName","setup","Promise","addEventListener","dispose","close","clear","request","createErrorResponse","readinessError","validateReady","message","submittedAt","set","postMessage","batch","requests","method","path","getSenderId","groupCollapsed","info","groupEnd","port","onmessage","start","isElectronEnvironment","success","test","navigator","userAgent"]}