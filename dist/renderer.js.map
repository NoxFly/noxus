{"version":3,"sources":["../src/index.ts","../src/request.ts","../src/DI/app-injector.ts","../src/exceptions.ts","../src/renderer-events.ts"],"sourcesContent":["/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport * from './request';\r\nexport * from './renderer-events';\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { AtomicHttpMethod, HttpMethod } from 'src/decorators/method.decorator';\r\nimport { AppInjector, RootInjector } from 'src/DI/app-injector';\r\n\r\n/**\r\n * The Request class represents an HTTP request in the Noxus framework.\r\n * It encapsulates the request data, including the event, ID, method, path, and body.\r\n * It also provides a context for dependency injection through the AppInjector.\r\n */\r\nexport class Request {\r\n    public readonly context: AppInjector = RootInjector.createScope();\r\n\r\n    public readonly params: Record<string, string> = {};\r\n\r\n    constructor(\r\n        public readonly event: Electron.MessageEvent,\r\n        public readonly id: string,\r\n        public readonly method: HttpMethod,\r\n        public readonly path: string,\r\n        public readonly body: any,\r\n    ) {\r\n        this.path = path.replace(/^\\/|\\/$/g, '');\r\n    }\r\n}\r\n\r\n/**\r\n * The IRequest interface defines the structure of a request object.\r\n * It includes properties for the sender ID, request ID, path, method, and an optional body.\r\n * This interface is used to standardize the request data across the application.\r\n */\r\nexport interface IRequest<TBody = unknown> {\r\n    senderId: number;\r\n    requestId: string;\r\n    path: string;\r\n    method: HttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestItem<TBody = unknown> {\r\n    requestId?: string;\r\n    path: string;\r\n    method: AtomicHttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestPayload {\r\n    requests: IBatchRequestItem[];\r\n}\r\n\r\n/**\r\n * Creates a Request object from the IPC event data.\r\n * This function extracts the necessary information from the IPC event and constructs a Request instance.\r\n */\r\nexport interface IResponse<TBody = unknown> {\r\n    requestId: string;\r\n    status: number;\r\n    body?: TBody;\r\n    error?: string;\r\n    stack?: string;\r\n}\r\n\r\nexport interface IBatchResponsePayload {\r\n    responses: IResponse[];\r\n}\r\n\r\nexport const RENDERER_EVENT_TYPE = 'noxus:event';\r\n\r\nexport interface IRendererEventMessage<TPayload = unknown> {\r\n    type: typeof RENDERER_EVENT_TYPE;\r\n    event: string;\r\n    payload?: TPayload;\r\n}\r\n\r\nexport function createRendererEventMessage<TPayload = unknown>(event: string, payload?: TPayload): IRendererEventMessage<TPayload> {\r\n    return {\r\n        type: RENDERER_EVENT_TYPE,\r\n        event,\r\n        payload,\r\n    };\r\n}\r\n\r\nexport function isRendererEventMessage(value: unknown): value is IRendererEventMessage {\r\n    if(value === null || typeof value !== 'object') {\r\n        return false;\r\n    }\r\n\r\n    const possibleMessage = value as Partial<IRendererEventMessage>;\r\n\r\n    return possibleMessage.type === RENDERER_EVENT_TYPE && typeof possibleMessage.event === 'string';\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { InternalServerException } from 'src/exceptions';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * Represents a lifetime of a binding in the dependency injection system.\r\n * It can be one of the following:\r\n * - 'singleton': The instance is created once and shared across the application.\r\n * - 'scope': The instance is created once per scope (e.g., per request).\r\n * - 'transient': A new instance is created every time it is requested.\r\n */\r\nexport type Lifetime = 'singleton' | 'scope' | 'transient';\r\n\r\n/**\r\n * Represents a binding in the dependency injection system.\r\n * It contains the lifetime of the binding, the implementation type, and optionally an instance.\r\n */\r\nexport interface IBinding {\r\n    lifetime: Lifetime;\r\n    implementation: Type<unknown>;\r\n    instance?: InstanceType<Type<unknown>>;\r\n}\r\n\r\n/**\r\n * AppInjector is the root dependency injection container.\r\n * It is used to register and resolve dependencies in the application.\r\n * It supports different lifetimes for dependencies:\r\n * This should not be manually instantiated, outside of the framework.\r\n * Use the `RootInjector` instance instead.\r\n */\r\nexport class AppInjector {\r\n    public bindings = new Map<Type<unknown>, IBinding>();\r\n    public singletons = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n    public scoped = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n\r\n    constructor(\r\n        public readonly name: string | null = null,\r\n    ) {}\r\n\r\n    /**\r\n     * Typically used to create a dependency injection scope\r\n     * at the \"scope\" level (i.e., per-request lifetime).\r\n     *\r\n     * SHOULD NOT BE USED by anything else than the framework itself.\r\n     */\r\n    public createScope(): AppInjector {\r\n        const scope = new AppInjector();\r\n        scope.bindings = this.bindings; // pass injectable declarations\r\n        scope.singletons = this.singletons; // share parent's singletons to avoid recreating them\r\n        // do not keep parent's scoped instances\r\n        return scope;\r\n    }\r\n\r\n    /**\r\n     * Called when resolving a dependency,\r\n     * i.e., retrieving the instance of a given class.\r\n     */\r\n    public resolve<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const binding = this.bindings.get(target);\r\n\r\n        if(!binding)\r\n            throw new InternalServerException(\r\n                `Failed to resolve a dependency injection : No binding for type ${target.name}.\\n`\r\n                + `Did you forget to use @Injectable() decorator ?`\r\n            );\r\n\r\n        switch(binding.lifetime) {\r\n            case 'transient':\r\n                return this.instantiate(binding.implementation) as InstanceType<T>;\r\n\r\n            case 'scope': {\r\n                if(this.scoped.has(target)) {\r\n                    return this.scoped.get(target) as InstanceType<T>;\r\n                }\r\n\r\n                const instance = this.instantiate(binding.implementation);\r\n                this.scoped.set(target, instance);\r\n\r\n                return instance as InstanceType<T>;\r\n            }\r\n\r\n            case 'singleton': {\r\n                if(binding.instance === undefined && this.name === 'root') {\r\n                    binding.instance = this.instantiate(binding.implementation);\r\n                    this.singletons.set(target, binding.instance);\r\n                }\r\n\r\n                return binding.instance as InstanceType<T>;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    private instantiate<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];\r\n        const params = paramTypes.map((p: any) => this.resolve(p));\r\n        return new target(...params) as InstanceType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Injects a type from the dependency injection system.\r\n * This function is used to retrieve an instance of a type that has been registered in the dependency injection system.\r\n * It is typically used in the constructor of a class to inject dependencies.\r\n * @param t - The type to inject.\r\n * @returns An instance of the type.\r\n * @throws If the type is not registered in the dependency injection system.\r\n */\r\nexport function inject<T>(t: Type<T>): T {\r\n    return RootInjector.resolve(t);\r\n}\r\n\r\nexport const RootInjector = new AppInjector('root');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport class ResponseException extends Error {\r\n    public readonly status: number = 0;\r\n\r\n    constructor(message?: string);\r\n    constructor(statusCode?: number, message?: string);\r\n    constructor(statusOrMessage?: number | string, message?: string) {\r\n        let statusCode: number | undefined;\r\n        \r\n        if(typeof statusOrMessage === 'number') {\r\n            statusCode = statusOrMessage;\r\n        }\r\n        else if(typeof statusOrMessage === 'string') {\r\n            message = statusOrMessage;\r\n        }\r\n\r\n        super(message ?? \"\");\r\n\r\n        if(statusCode !== undefined) {\r\n            this.status = statusCode;\r\n        }\r\n        \r\n        this.name = this.constructor.name\r\n            .replace(/([A-Z])/g, ' $1');\r\n    }\r\n}\r\n\r\n// 4XX\r\nexport class BadRequestException extends ResponseException { public override readonly status = 400; }\r\nexport class UnauthorizedException extends ResponseException { public override readonly status = 401; }\r\nexport class PaymentRequiredException extends ResponseException { public override readonly status = 402; }\r\nexport class ForbiddenException extends ResponseException { public override readonly status = 403; }\r\nexport class NotFoundException extends ResponseException { public override readonly status = 404; }\r\nexport class MethodNotAllowedException extends ResponseException { public override readonly status = 405; }\r\nexport class NotAcceptableException extends ResponseException { public override readonly status = 406; }\r\nexport class RequestTimeoutException extends ResponseException { public override readonly status = 408; }\r\nexport class ConflictException extends ResponseException { public override readonly status = 409; }\r\nexport class UpgradeRequiredException extends ResponseException { public override readonly status = 426; }\r\nexport class TooManyRequestsException extends ResponseException { public override readonly status = 429; }\r\n// 5XX\r\nexport class InternalServerException extends ResponseException { public override readonly status = 500; }\r\nexport class NotImplementedException extends ResponseException { public override readonly status = 501; }\r\nexport class BadGatewayException extends ResponseException { public override readonly status = 502; }\r\nexport class ServiceUnavailableException extends ResponseException { public override readonly status = 503; }\r\nexport class GatewayTimeoutException extends ResponseException { public override readonly status = 504; }\r\nexport class HttpVersionNotSupportedException extends ResponseException { public override readonly status = 505; }\r\nexport class VariantAlsoNegotiatesException extends ResponseException { public override readonly status = 506; }\r\nexport class InsufficientStorageException extends ResponseException { public override readonly status = 507; }\r\nexport class LoopDetectedException extends ResponseException { public override readonly status = 508; }\r\nexport class NotExtendedException extends ResponseException { public override readonly status = 510; }\r\nexport class NetworkAuthenticationRequiredException extends ResponseException { public override readonly status = 511; }\r\nexport class NetworkConnectTimeoutException extends ResponseException { public override readonly status = 599; }\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Lightweight event registry to help renderer processes subscribe to\r\n * push messages sent by the main process through Noxus.\r\n */\r\nimport { IRendererEventMessage, isRendererEventMessage } from 'src/request';\r\n\r\nexport type RendererEventHandler<TPayload = unknown> = (payload: TPayload) => void;\r\n\r\nexport interface RendererEventSubscription {\r\n    unsubscribe(): void;\r\n}\r\n\r\nexport class RendererEventRegistry {\r\n    private readonly listeners = new Map<string, Set<RendererEventHandler>>();\r\n\r\n    /**\r\n     *\r\n     */\r\n    public subscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): RendererEventSubscription {\r\n        const normalizedEventName = eventName.trim();\r\n\r\n        if(normalizedEventName.length === 0) {\r\n            throw new Error('Renderer event name must be a non-empty string.');\r\n        }\r\n\r\n        const handlers = this.listeners.get(normalizedEventName) ?? new Set<RendererEventHandler>();\r\n\r\n        handlers.add(handler as RendererEventHandler);\r\n        this.listeners.set(normalizedEventName, handlers);\r\n\r\n        return {\r\n            unsubscribe: () => this.unsubscribe(normalizedEventName, handler as RendererEventHandler),\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public unsubscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): void {\r\n        const handlers = this.listeners.get(eventName);\r\n\r\n        if(!handlers) {\r\n            return;\r\n        }\r\n\r\n        handlers.delete(handler as RendererEventHandler);\r\n\r\n        if(handlers.size === 0) {\r\n            this.listeners.delete(eventName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public clear(eventName?: string): void {\r\n        if(eventName) {\r\n            this.listeners.delete(eventName);\r\n            return;\r\n        }\r\n\r\n        this.listeners.clear();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public dispatch<TPayload>(message: IRendererEventMessage<TPayload>): void {\r\n        const handlers = this.listeners.get(message.event);\r\n\r\n        if(!handlers || handlers.size === 0) {\r\n            return;\r\n        }\r\n\r\n        handlers.forEach((handler) => {\r\n            try {\r\n                handler(message.payload as TPayload);\r\n            }\r\n            catch(error) {\r\n                console.error(`[Noxus] Renderer event handler for \"${message.event}\" threw an error.`, error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public tryDispatchFromMessageEvent(event: MessageEvent): boolean {\r\n        if(!isRendererEventMessage(event.data)) {\r\n            return false;\r\n        }\r\n\r\n        this.dispatch(event.data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public hasHandlers(eventName: string): boolean {\r\n        const handlers = this.listeners.get(eventName);\r\n        return !!handlers && handlers.size > 0;\r\n    }\r\n}\r\n"],"mappings":"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","names":["import_reflect_metadata","ResponseException","Error","statusOrMessage","message","statusCode","status","undefined","name","replace","InternalServerException","ResponseException","status","AppInjector","name","bindings","Map","singletons","scoped","createScope","scope","resolve","target","binding","get","InternalServerException","lifetime","instantiate","implementation","has","instance","set","undefined","paramTypes","Reflect","getMetadata","params","map","p","RootInjector","AppInjector","Request","event","id","method","path","body","context","RootInjector","createScope","params","replace","RENDERER_EVENT_TYPE","createRendererEventMessage","payload","type","isRendererEventMessage","value","possibleMessage","RendererEventRegistry","listeners","Map","subscribe","eventName","handler","normalizedEventName","trim","length","Error","handlers","get","Set","add","set","unsubscribe","delete","size","clear","dispatch","message","event","forEach","payload","error","console","tryDispatchFromMessageEvent","isRendererEventMessage","data","hasHandlers"]}