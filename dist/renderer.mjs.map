{"version":3,"sources":["../src/request.ts","../src/DI/app-injector.ts","../src/exceptions.ts","../src/renderer-events.ts","../src/renderer-client.ts","../src/preload-bridge.ts"],"sourcesContent":["/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { AtomicHttpMethod, HttpMethod } from 'src/decorators/method.decorator';\r\nimport { AppInjector, RootInjector } from 'src/DI/app-injector';\r\n\r\n/**\r\n * The Request class represents an HTTP request in the Noxus framework.\r\n * It encapsulates the request data, including the event, ID, method, path, and body.\r\n * It also provides a context for dependency injection through the AppInjector.\r\n */\r\nexport class Request {\r\n    public readonly context: AppInjector = RootInjector.createScope();\r\n\r\n    public readonly params: Record<string, string> = {};\r\n\r\n    constructor(\r\n        public readonly event: Electron.MessageEvent,\r\n        public readonly senderId: number,\r\n        public readonly id: string,\r\n        public readonly method: HttpMethod,\r\n        public readonly path: string,\r\n        public readonly body: any,\r\n    ) {\r\n        this.path = path.replace(/^\\/|\\/$/g, '');\r\n    }\r\n}\r\n\r\n/**\r\n * The IRequest interface defines the structure of a request object.\r\n * It includes properties for the sender ID, request ID, path, method, and an optional body.\r\n * This interface is used to standardize the request data across the application.\r\n */\r\nexport interface IRequest<TBody = unknown> {\r\n    senderId: number;\r\n    requestId: string;\r\n    path: string;\r\n    method: HttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestItem<TBody = unknown> {\r\n    requestId?: string;\r\n    path: string;\r\n    method: AtomicHttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestPayload {\r\n    requests: IBatchRequestItem[];\r\n}\r\n\r\n/**\r\n * Creates a Request object from the IPC event data.\r\n * This function extracts the necessary information from the IPC event and constructs a Request instance.\r\n */\r\nexport interface IResponse<TBody = unknown> {\r\n    requestId: string;\r\n    status: number;\r\n    body?: TBody;\r\n    error?: string;\r\n    stack?: string;\r\n}\r\n\r\nexport interface IBatchResponsePayload {\r\n    responses: IResponse[];\r\n}\r\n\r\nexport const RENDERER_EVENT_TYPE = 'noxus:event';\r\n\r\nexport interface IRendererEventMessage<TPayload = unknown> {\r\n    type: typeof RENDERER_EVENT_TYPE;\r\n    event: string;\r\n    payload?: TPayload;\r\n}\r\n\r\nexport function createRendererEventMessage<TPayload = unknown>(event: string, payload?: TPayload): IRendererEventMessage<TPayload> {\r\n    return {\r\n        type: RENDERER_EVENT_TYPE,\r\n        event,\r\n        payload,\r\n    };\r\n}\r\n\r\nexport function isRendererEventMessage(value: unknown): value is IRendererEventMessage {\r\n    if(value === null || typeof value !== 'object') {\r\n        return false;\r\n    }\r\n\r\n    const possibleMessage = value as Partial<IRendererEventMessage>;\r\n\r\n    return possibleMessage.type === RENDERER_EVENT_TYPE && typeof possibleMessage.event === 'string';\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { InternalServerException } from 'src/exceptions';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * Represents a lifetime of a binding in the dependency injection system.\r\n * It can be one of the following:\r\n * - 'singleton': The instance is created once and shared across the application.\r\n * - 'scope': The instance is created once per scope (e.g., per request).\r\n * - 'transient': A new instance is created every time it is requested.\r\n */\r\nexport type Lifetime = 'singleton' | 'scope' | 'transient';\r\n\r\n/**\r\n * Represents a binding in the dependency injection system.\r\n * It contains the lifetime of the binding, the implementation type, and optionally an instance.\r\n */\r\nexport interface IBinding {\r\n    lifetime: Lifetime;\r\n    implementation: Type<unknown>;\r\n    instance?: InstanceType<Type<unknown>>;\r\n}\r\n\r\n/**\r\n * AppInjector is the root dependency injection container.\r\n * It is used to register and resolve dependencies in the application.\r\n * It supports different lifetimes for dependencies:\r\n * This should not be manually instantiated, outside of the framework.\r\n * Use the `RootInjector` instance instead.\r\n */\r\nexport class AppInjector {\r\n    public bindings = new Map<Type<unknown>, IBinding>();\r\n    public singletons = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n    public scoped = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n\r\n    constructor(\r\n        public readonly name: string | null = null,\r\n    ) {}\r\n\r\n    /**\r\n     * Typically used to create a dependency injection scope\r\n     * at the \"scope\" level (i.e., per-request lifetime).\r\n     *\r\n     * SHOULD NOT BE USED by anything else than the framework itself.\r\n     */\r\n    public createScope(): AppInjector {\r\n        const scope = new AppInjector();\r\n        scope.bindings = this.bindings; // pass injectable declarations\r\n        scope.singletons = this.singletons; // share parent's singletons to avoid recreating them\r\n        // do not keep parent's scoped instances\r\n        return scope;\r\n    }\r\n\r\n    /**\r\n     * Called when resolving a dependency,\r\n     * i.e., retrieving the instance of a given class.\r\n     */\r\n    public resolve<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const binding = this.bindings.get(target);\r\n\r\n        if(!binding)\r\n            throw new InternalServerException(\r\n                `Failed to resolve a dependency injection : No binding for type ${target.name}.\\n`\r\n                + `Did you forget to use @Injectable() decorator ?`\r\n            );\r\n\r\n        switch(binding.lifetime) {\r\n            case 'transient':\r\n                return this.instantiate(binding.implementation) as InstanceType<T>;\r\n\r\n            case 'scope': {\r\n                if(this.scoped.has(target)) {\r\n                    return this.scoped.get(target) as InstanceType<T>;\r\n                }\r\n\r\n                const instance = this.instantiate(binding.implementation);\r\n                this.scoped.set(target, instance);\r\n\r\n                return instance as InstanceType<T>;\r\n            }\r\n\r\n            case 'singleton': {\r\n                if(binding.instance === undefined && this.name === 'root') {\r\n                    binding.instance = this.instantiate(binding.implementation);\r\n                    this.singletons.set(target, binding.instance);\r\n                }\r\n\r\n                return binding.instance as InstanceType<T>;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    private instantiate<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];\r\n        const params = paramTypes.map((p: any) => this.resolve(p));\r\n        return new target(...params) as InstanceType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Injects a type from the dependency injection system.\r\n * This function is used to retrieve an instance of a type that has been registered in the dependency injection system.\r\n * It is typically used in the constructor of a class to inject dependencies.\r\n * @param t - The type to inject.\r\n * @returns An instance of the type.\r\n * @throws If the type is not registered in the dependency injection system.\r\n */\r\nexport function inject<T>(t: Type<T>): T {\r\n    return RootInjector.resolve(t);\r\n}\r\n\r\nexport const RootInjector = new AppInjector('root');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport class ResponseException extends Error {\r\n    public readonly status: number = 0;\r\n\r\n    constructor(message?: string);\r\n    constructor(statusCode?: number, message?: string);\r\n    constructor(statusOrMessage?: number | string, message?: string) {\r\n        let statusCode: number | undefined;\r\n        \r\n        if(typeof statusOrMessage === 'number') {\r\n            statusCode = statusOrMessage;\r\n        }\r\n        else if(typeof statusOrMessage === 'string') {\r\n            message = statusOrMessage;\r\n        }\r\n\r\n        super(message ?? \"\");\r\n\r\n        if(statusCode !== undefined) {\r\n            this.status = statusCode;\r\n        }\r\n        \r\n        this.name = this.constructor.name\r\n            .replace(/([A-Z])/g, ' $1');\r\n    }\r\n}\r\n\r\n// 4XX\r\nexport class BadRequestException extends ResponseException { public override readonly status = 400; }\r\nexport class UnauthorizedException extends ResponseException { public override readonly status = 401; }\r\nexport class PaymentRequiredException extends ResponseException { public override readonly status = 402; }\r\nexport class ForbiddenException extends ResponseException { public override readonly status = 403; }\r\nexport class NotFoundException extends ResponseException { public override readonly status = 404; }\r\nexport class MethodNotAllowedException extends ResponseException { public override readonly status = 405; }\r\nexport class NotAcceptableException extends ResponseException { public override readonly status = 406; }\r\nexport class RequestTimeoutException extends ResponseException { public override readonly status = 408; }\r\nexport class ConflictException extends ResponseException { public override readonly status = 409; }\r\nexport class UpgradeRequiredException extends ResponseException { public override readonly status = 426; }\r\nexport class TooManyRequestsException extends ResponseException { public override readonly status = 429; }\r\n// 5XX\r\nexport class InternalServerException extends ResponseException { public override readonly status = 500; }\r\nexport class NotImplementedException extends ResponseException { public override readonly status = 501; }\r\nexport class BadGatewayException extends ResponseException { public override readonly status = 502; }\r\nexport class ServiceUnavailableException extends ResponseException { public override readonly status = 503; }\r\nexport class GatewayTimeoutException extends ResponseException { public override readonly status = 504; }\r\nexport class HttpVersionNotSupportedException extends ResponseException { public override readonly status = 505; }\r\nexport class VariantAlsoNegotiatesException extends ResponseException { public override readonly status = 506; }\r\nexport class InsufficientStorageException extends ResponseException { public override readonly status = 507; }\r\nexport class LoopDetectedException extends ResponseException { public override readonly status = 508; }\r\nexport class NotExtendedException extends ResponseException { public override readonly status = 510; }\r\nexport class NetworkAuthenticationRequiredException extends ResponseException { public override readonly status = 511; }\r\nexport class NetworkConnectTimeoutException extends ResponseException { public override readonly status = 599; }\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Lightweight event registry to help renderer processes subscribe to\r\n * push messages sent by the main process through Noxus.\r\n */\r\nimport { IRendererEventMessage, isRendererEventMessage } from 'src/request';\r\n\r\nexport type RendererEventHandler<TPayload = unknown> = (payload: TPayload) => void;\r\n\r\nexport interface RendererEventSubscription {\r\n    unsubscribe(): void;\r\n}\r\n\r\nexport class RendererEventRegistry {\r\n    private readonly listeners = new Map<string, Set<RendererEventHandler>>();\r\n\r\n    /**\r\n     *\r\n     */\r\n    public subscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): RendererEventSubscription {\r\n        const normalizedEventName = eventName.trim();\r\n\r\n        if(normalizedEventName.length === 0) {\r\n            throw new Error('Renderer event name must be a non-empty string.');\r\n        }\r\n\r\n        const handlers = this.listeners.get(normalizedEventName) ?? new Set<RendererEventHandler>();\r\n\r\n        handlers.add(handler as RendererEventHandler);\r\n        this.listeners.set(normalizedEventName, handlers);\r\n\r\n        return {\r\n            unsubscribe: () => this.unsubscribe(normalizedEventName, handler as RendererEventHandler),\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public unsubscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): void {\r\n        const handlers = this.listeners.get(eventName);\r\n\r\n        if(!handlers) {\r\n            return;\r\n        }\r\n\r\n        handlers.delete(handler as RendererEventHandler);\r\n\r\n        if(handlers.size === 0) {\r\n            this.listeners.delete(eventName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public clear(eventName?: string): void {\r\n        if(eventName) {\r\n            this.listeners.delete(eventName);\r\n            return;\r\n        }\r\n\r\n        this.listeners.clear();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public dispatch<TPayload>(message: IRendererEventMessage<TPayload>): void {\r\n        const handlers = this.listeners.get(message.event);\r\n\r\n        if(!handlers || handlers.size === 0) {\r\n            return;\r\n        }\r\n\r\n        handlers.forEach((handler) => {\r\n            try {\r\n                handler(message.payload as TPayload);\r\n            }\r\n            catch(error) {\r\n                console.error(`[Noxus] Renderer event handler for \"${message.event}\" threw an error.`, error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public tryDispatchFromMessageEvent(event: MessageEvent): boolean {\r\n        if(!isRendererEventMessage(event.data)) {\r\n            return false;\r\n        }\r\n\r\n        this.dispatch(event.data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public hasHandlers(eventName: string): boolean {\r\n        const handlers = this.listeners.get(eventName);\r\n        return !!handlers && handlers.size > 0;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { IBatchRequestItem, IBatchResponsePayload, IRequest, IResponse } from 'src/request';\r\nimport { RendererEventRegistry } from 'src/renderer-events';\r\n\r\nexport interface IPortRequester {\r\n    requestPort(): void;\r\n}\r\n\r\nexport interface RendererClientOptions {\r\n    bridge?: IPortRequester | null;\r\n    bridgeName?: string | string[];\r\n    initMessageType?: string;\r\n    windowRef?: Window;\r\n    generateRequestId?: () => string;\r\n}\r\n\r\ninterface PendingRequest<T = unknown> {\r\n    resolve: (value: T) => void;\r\n    reject: (reason: IResponse<T>) => void;\r\n    request: IRequest;\r\n    submittedAt: number;\r\n}\r\n\r\nconst DEFAULT_INIT_EVENT = 'init-port';\r\nconst DEFAULT_BRIDGE_NAMES = ['noxus', 'ipcRenderer'];\r\n\r\nfunction defaultRequestId(): string {\r\n    if(typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\r\n        return crypto.randomUUID();\r\n    }\r\n\r\n    return `${Date.now().toString(16)}-${Math.floor(Math.random() * 1e8).toString(16)}`;\r\n}\r\n\r\nfunction normalizeBridgeNames(preferred?: string | string[]): string[] {\r\n    const names: string[] = [];\r\n\r\n    const add = (name: string | undefined): void => {\r\n        if(!name)\r\n            return;\r\n\r\n        if(!names.includes(name)) {\r\n            names.push(name);\r\n        }\r\n    };\r\n\r\n    if(Array.isArray(preferred)) {\r\n        for(const name of preferred) {\r\n            add(name);\r\n        }\r\n    }\r\n    else {\r\n        add(preferred);\r\n    }\r\n\r\n    for(const fallback of DEFAULT_BRIDGE_NAMES) {\r\n        add(fallback);\r\n    }\r\n\r\n    return names;\r\n}\r\n\r\nfunction resolveBridgeFromWindow(windowRef: Window, preferred?: string | string[]): IPortRequester | null {\r\n    const names = normalizeBridgeNames(preferred);\r\n    const globalRef = windowRef as unknown as Record<string, unknown> | null | undefined;\r\n\r\n    if(!globalRef) {\r\n        return null;\r\n    }\r\n\r\n    for(const name of names) {\r\n        const candidate = globalRef[name];\r\n\r\n        if(candidate && typeof (candidate as IPortRequester).requestPort === 'function') {\r\n            return candidate as IPortRequester;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport class NoxRendererClient {\r\n    public readonly events = new RendererEventRegistry();\r\n\r\n    protected readonly pendingRequests = new Map<string, PendingRequest>();\r\n\r\n    protected requestPort: MessagePort | undefined;\r\n    protected socketPort: MessagePort | undefined;\r\n    protected senderId: number | undefined;\r\n\r\n    private readonly bridge: IPortRequester | null;\r\n    private readonly initMessageType: string;\r\n    private readonly windowRef: Window;\r\n    private readonly generateRequestId: () => string;\r\n\r\n    private isReady = false;\r\n    private setupPromise: Promise<void> | undefined;\r\n    private setupResolve: (() => void) | undefined;\r\n    private setupReject: ((reason: Error) => void) | undefined;\r\n\r\n    constructor(options: RendererClientOptions = {}) {\r\n        this.windowRef = options.windowRef ?? window;\r\n        const resolvedBridge = options.bridge ?? resolveBridgeFromWindow(this.windowRef, options.bridgeName);\r\n        this.bridge = resolvedBridge ?? null;\r\n        this.initMessageType = options.initMessageType ?? DEFAULT_INIT_EVENT;\r\n        this.generateRequestId = options.generateRequestId ?? defaultRequestId;\r\n    }\r\n\r\n    public async setup(): Promise<void> {\r\n        if(this.isReady) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if(this.setupPromise) {\r\n            return this.setupPromise;\r\n        }\r\n\r\n        if(!this.bridge || typeof this.bridge.requestPort !== 'function') {\r\n            throw new Error('[Noxus] Renderer bridge is missing requestPort().');\r\n        }\r\n\r\n        this.setupPromise = new Promise<void>((resolve, reject) => {\r\n            this.setupResolve = resolve;\r\n            this.setupReject = reject;\r\n        });\r\n\r\n        this.windowRef.addEventListener('message', this.onWindowMessage);\r\n        this.bridge.requestPort();\r\n\r\n        return this.setupPromise;\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort?.close();\r\n        this.socketPort?.close();\r\n\r\n        this.requestPort = undefined;\r\n        this.socketPort = undefined;\r\n        this.senderId = undefined;\r\n        this.isReady = false;\r\n\r\n        this.pendingRequests.clear();\r\n    }\r\n\r\n    public async request<TResponse, TBody = unknown>(request: Omit<IRequest<TBody>, 'requestId' | 'senderId'>): Promise<TResponse> {\r\n        const senderId = this.senderId;\r\n        const requestId = this.generateRequestId();\r\n\r\n        if(senderId === undefined) {\r\n            return Promise.reject(this.createErrorResponse(requestId, 'MessagePort is not available'));\r\n        }\r\n\r\n        const readinessError = this.validateReady(requestId);\r\n\r\n        if(readinessError) {\r\n            return Promise.reject(readinessError as IResponse<TResponse>);\r\n        }\r\n\r\n        const message: IRequest<TBody> = {\r\n            requestId,\r\n            senderId,\r\n            ...request,\r\n        };\r\n\r\n        return new Promise<TResponse>((resolve, reject) => {\r\n            const pending: PendingRequest<TResponse> = {\r\n                resolve,\r\n                reject: (response: IResponse<TResponse>) => reject(response),\r\n                request: message,\r\n                submittedAt: Date.now(),\r\n            };\r\n\r\n            this.pendingRequests.set(message.requestId, pending as PendingRequest);\r\n\r\n            this.requestPort!.postMessage(message);\r\n        });\r\n    }\r\n\r\n    public async batch(requests: Omit<IBatchRequestItem<unknown>, 'requestId'>[]): Promise<IBatchResponsePayload> {\r\n        return this.request<IBatchResponsePayload>({\r\n            method: 'BATCH',\r\n            path: '',\r\n            body: {\r\n                requests,\r\n            },\r\n        });\r\n    }\r\n\r\n    public getSenderId(): number | undefined {\r\n        return this.senderId;\r\n    }\r\n\r\n    private readonly onWindowMessage = (event: MessageEvent): void => {\r\n        if(event.data?.type !== this.initMessageType) {\r\n            return;\r\n        }\r\n\r\n        if(!Array.isArray(event.ports) || event.ports.length < 2) {\r\n            const error = new Error('[Noxus] Renderer expected two MessagePorts (request + socket).');\r\n\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort = event.ports[0];\r\n        this.socketPort = event.ports[1];\r\n        this.senderId = event.data.senderId;\r\n\r\n        if(this.requestPort === undefined || this.socketPort === undefined) {\r\n            const error = new Error('[Noxus] Renderer failed to receive valid MessagePorts.');\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.attachRequestPort(this.requestPort);\r\n        this.attachSocketPort(this.socketPort);\r\n\r\n        this.isReady = true;\r\n        this.setupResolve?.();\r\n        this.resetSetupState(true);\r\n    };\r\n\r\n    private readonly onSocketMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        console.warn('[Noxus] Received a socket message that is not a renderer event payload.', event.data);\r\n    };\r\n\r\n    private readonly onRequestMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        const response: IResponse = event.data;\r\n\r\n        if(!response || typeof response.requestId !== 'string') {\r\n            console.error('[Noxus] Renderer received an invalid response payload.', response);\r\n            return;\r\n        }\r\n\r\n        const pending = this.pendingRequests.get(response.requestId);\r\n\r\n        if(!pending) {\r\n            console.error(`[Noxus] No pending handler found for request ${response.requestId}.`);\r\n            return;\r\n        }\r\n\r\n        this.pendingRequests.delete(response.requestId);\r\n\r\n        this.onRequestCompleted(pending, response);\r\n\r\n        if(response.status >= 400) {\r\n            pending.reject(response as IResponse<any>);\r\n            return;\r\n        }\r\n\r\n        pending.resolve(response.body as unknown);\r\n    };\r\n\r\n    protected onRequestCompleted(pending: PendingRequest, response: IResponse): void {\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupCollapsed(`${response.status} ${pending.request.method} /${pending.request.path}`);\r\n        }\r\n\r\n        if(response.error) {\r\n            console.error('error message:', response.error);\r\n        }\r\n\r\n        if(response.body !== undefined) {\r\n            console.info('response:', response.body);\r\n        }\r\n\r\n        console.info('request:', pending.request);\r\n        console.info(`Request duration: ${Date.now() - pending.submittedAt} ms`);\r\n\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupEnd();\r\n        }\r\n    }\r\n\r\n    private attachRequestPort(port: MessagePort): void {\r\n        port.onmessage = this.onRequestMessage;\r\n        port.start();\r\n    }\r\n\r\n    private attachSocketPort(port: MessagePort): void {\r\n        port.onmessage = this.onSocketMessage;\r\n        port.start();\r\n    }\r\n\r\n    private validateReady(requestId: string): IResponse | undefined {\r\n        if(!this.isElectronEnvironment()) {\r\n            return this.createErrorResponse(requestId, 'Not running in Electron environment');\r\n        }\r\n\r\n        if(!this.requestPort) {\r\n            return this.createErrorResponse(requestId, 'MessagePort is not available');\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private createErrorResponse<T>(requestId: string, message: string): IResponse<T> {\r\n        return {\r\n            status: 500,\r\n            requestId,\r\n            error: message,\r\n        };\r\n    }\r\n\r\n    private resetSetupState(success = false): void {\r\n        if(!success) {\r\n            this.setupPromise = undefined;\r\n        }\r\n\r\n        this.setupResolve = undefined;\r\n        this.setupReject = undefined;\r\n    }\r\n\r\n    protected isElectronEnvironment(): boolean {\r\n        return typeof window !== 'undefined' && /Electron/.test(window.navigator.userAgent);\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { contextBridge, ipcRenderer } from 'electron/renderer';\r\nimport type { IPortRequester } from 'src/renderer-client';\r\n\r\nexport interface NoxusPreloadAPI extends IPortRequester {}\r\n\r\nexport interface NoxusPreloadOptions {\r\n    exposeAs?: string;\r\n    initMessageType?: string;\r\n    requestChannel?: string;\r\n    responseChannel?: string;\r\n    targetWindow?: Window;\r\n}\r\n\r\nconst DEFAULT_EXPOSE_NAME = 'noxus';\r\nconst DEFAULT_INIT_EVENT = 'init-port';\r\nconst DEFAULT_REQUEST_CHANNEL = 'gimme-my-port';\r\nconst DEFAULT_RESPONSE_CHANNEL = 'port';\r\n\r\n/**\r\n * Exposes a minimal bridge in the isolated preload context so renderer processes\r\n * can request the two MessagePorts required by Noxus. The bridge forwards both\r\n * request/response and socket ports to the renderer via window.postMessage.\r\n */\r\nexport function exposeNoxusBridge(options: NoxusPreloadOptions = {}): NoxusPreloadAPI {\r\n    const {\r\n        exposeAs = DEFAULT_EXPOSE_NAME,\r\n        initMessageType = DEFAULT_INIT_EVENT,\r\n        requestChannel = DEFAULT_REQUEST_CHANNEL,\r\n        responseChannel = DEFAULT_RESPONSE_CHANNEL,\r\n        targetWindow = window,\r\n    } = options;\r\n\r\n    const api: NoxusPreloadAPI = {\r\n        requestPort: () => {\r\n            ipcRenderer.send(requestChannel);\r\n\r\n            ipcRenderer.once(responseChannel, (event, message: { senderId: number }) => {\r\n                const ports = (event.ports ?? []).filter((port): port is MessagePort => port !== undefined);\r\n\r\n                if(ports.length === 0) {\r\n                    console.error('[Noxus] No MessagePort received from main process.');\r\n                    return;\r\n                }\r\n\r\n                for(const port of ports) {\r\n                    try {\r\n                        port.start();\r\n                    }\r\n                    catch(error) {\r\n                        console.error('[Noxus] Failed to start MessagePort.', error);\r\n                    }\r\n                }\r\n\r\n                targetWindow.postMessage(\r\n                    {\r\n                        type: initMessageType,\r\n                        senderId: message?.senderId,\r\n                    },\r\n                    '*',\r\n                    ports,\r\n                );\r\n            });\r\n        },\r\n    };\r\n\r\n    contextBridge.exposeInMainWorld(exposeAs, api);\r\n\r\n    return api;\r\n}\r\n"],"mappings":"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","names":["ResponseException","Error","statusOrMessage","message","statusCode","status","undefined","name","replace","InternalServerException","ResponseException","status","AppInjector","name","bindings","Map","singletons","scoped","createScope","scope","resolve","target","binding","get","InternalServerException","lifetime","instantiate","implementation","has","instance","set","undefined","paramTypes","Reflect","getMetadata","params","map","p","RootInjector","AppInjector","Request","event","senderId","id","method","path","body","context","RootInjector","createScope","params","replace","RENDERER_EVENT_TYPE","createRendererEventMessage","payload","type","isRendererEventMessage","value","possibleMessage","RendererEventRegistry","listeners","Map","subscribe","eventName","handler","normalizedEventName","trim","length","Error","handlers","get","Set","add","set","unsubscribe","delete","size","clear","dispatch","message","event","forEach","payload","error","console","tryDispatchFromMessageEvent","isRendererEventMessage","data","hasHandlers","DEFAULT_INIT_EVENT","DEFAULT_BRIDGE_NAMES","defaultRequestId","crypto","randomUUID","Date","now","toString","Math","floor","random","normalizeBridgeNames","preferred","names","add","name","includes","push","Array","isArray","fallback","resolveBridgeFromWindow","windowRef","globalRef","candidate","requestPort","NoxRendererClient","options","events","RendererEventRegistry","pendingRequests","Map","socketPort","senderId","bridge","initMessageType","generateRequestId","isReady","setupPromise","setupResolve","setupReject","onWindowMessage","event","data","type","ports","length","error","Error","console","resetSetupState","removeEventListener","undefined","attachRequestPort","attachSocketPort","onSocketMessage","tryDispatchFromMessageEvent","warn","onRequestMessage","response","requestId","pending","get","delete","onRequestCompleted","status","reject","resolve","body","window","resolvedBridge","bridgeName","setup","Promise","addEventListener","dispose","close","clear","request","createErrorResponse","readinessError","validateReady","message","submittedAt","set","postMessage","batch","requests","method","path","getSenderId","groupCollapsed","info","groupEnd","port","onmessage","start","isElectronEnvironment","success","test","navigator","userAgent","contextBridge","ipcRenderer","DEFAULT_EXPOSE_NAME","DEFAULT_INIT_EVENT","DEFAULT_REQUEST_CHANNEL","DEFAULT_RESPONSE_CHANNEL","exposeNoxusBridge","options","exposeAs","initMessageType","requestChannel","responseChannel","targetWindow","window","api","requestPort","ipcRenderer","send","once","event","message","ports","filter","port","undefined","length","console","error","start","postMessage","type","senderId","contextBridge","exposeInMainWorld"]}