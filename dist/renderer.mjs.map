{"version":3,"sources":["../src/request.ts","../src/DI/app-injector.ts","../src/decorators/inject.decorator.ts","../src/exceptions.ts","../src/utils/forward-ref.ts","../src/renderer-events.ts","../src/renderer-client.ts"],"sourcesContent":["/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { AtomicHttpMethod, HttpMethod } from 'src/decorators/method.decorator';\r\nimport { AppInjector, RootInjector } from 'src/DI/app-injector';\r\n\r\n/**\r\n * The Request class represents an HTTP request in the Noxus framework.\r\n * It encapsulates the request data, including the event, ID, method, path, and body.\r\n * It also provides a context for dependency injection through the AppInjector.\r\n */\r\nexport class Request {\r\n    public readonly context: AppInjector = RootInjector.createScope();\r\n\r\n    public readonly params: Record<string, string> = {};\r\n\r\n    constructor(\r\n        public readonly event: Electron.MessageEvent,\r\n        public readonly senderId: number,\r\n        public readonly id: string,\r\n        public readonly method: HttpMethod,\r\n        public readonly path: string,\r\n        public readonly body: any,\r\n    ) {\r\n        this.path = path.replace(/^\\/|\\/$/g, '');\r\n    }\r\n}\r\n\r\n/**\r\n * The IRequest interface defines the structure of a request object.\r\n * It includes properties for the sender ID, request ID, path, method, and an optional body.\r\n * This interface is used to standardize the request data across the application.\r\n */\r\nexport interface IRequest<TBody = unknown> {\r\n    senderId: number;\r\n    requestId: string;\r\n    path: string;\r\n    method: HttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestItem<TBody = unknown> {\r\n    requestId?: string;\r\n    path: string;\r\n    method: AtomicHttpMethod;\r\n    body?: TBody;\r\n}\r\n\r\nexport interface IBatchRequestPayload {\r\n    requests: IBatchRequestItem[];\r\n}\r\n\r\n/**\r\n * Creates a Request object from the IPC event data.\r\n * This function extracts the necessary information from the IPC event and constructs a Request instance.\r\n */\r\nexport interface IResponse<TBody = unknown> {\r\n    requestId: string;\r\n    status: number;\r\n    body?: TBody;\r\n    error?: string;\r\n    stack?: string;\r\n}\r\n\r\nexport interface IBatchResponsePayload {\r\n    responses: IResponse[];\r\n}\r\n\r\nexport const RENDERER_EVENT_TYPE = 'noxus:event';\r\n\r\nexport interface IRendererEventMessage<TPayload = unknown> {\r\n    type: typeof RENDERER_EVENT_TYPE;\r\n    event: string;\r\n    payload?: TPayload;\r\n}\r\n\r\nexport function createRendererEventMessage<TPayload = unknown>(event: string, payload?: TPayload): IRendererEventMessage<TPayload> {\r\n    return {\r\n        type: RENDERER_EVENT_TYPE,\r\n        event,\r\n        payload,\r\n    };\r\n}\r\n\r\nexport function isRendererEventMessage(value: unknown): value is IRendererEventMessage {\r\n    if(value === null || typeof value !== 'object') {\r\n        return false;\r\n    }\r\n\r\n    const possibleMessage = value as Partial<IRendererEventMessage>;\r\n\r\n    return possibleMessage.type === RENDERER_EVENT_TYPE && typeof possibleMessage.event === 'string';\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { INJECT_METADATA_KEY } from 'src/decorators/inject.decorator';\r\nimport { InternalServerException } from 'src/exceptions';\r\nimport { ForwardReference } from 'src/utils/forward-ref';\r\nimport { Type } from 'src/utils/types';\r\n\r\n/**\r\n * Represents a lifetime of a binding in the dependency injection system.\r\n * It can be one of the following:\r\n * - 'singleton': The instance is created once and shared across the application.\r\n * - 'scope': The instance is created once per scope (e.g., per request).\r\n * - 'transient': A new instance is created every time it is requested.\r\n */\r\nexport type Lifetime = 'singleton' | 'scope' | 'transient';\r\n\r\n/**\r\n * Represents a binding in the dependency injection system.\r\n * It contains the lifetime of the binding, the implementation type, and optionally an instance.\r\n */\r\nexport interface IBinding {\r\n    lifetime: Lifetime;\r\n    implementation: Type<unknown>;\r\n    instance?: InstanceType<Type<unknown>>;\r\n}\r\n\r\n/**\r\n * AppInjector is the root dependency injection container.\r\n * It is used to register and resolve dependencies in the application.\r\n * It supports different lifetimes for dependencies:\r\n * This should not be manually instantiated, outside of the framework.\r\n * Use the `RootInjector` instance instead.\r\n */\r\nexport class AppInjector {\r\n    public bindings = new Map<Type<unknown>, IBinding>();\r\n    public singletons = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n    public scoped = new Map<Type<unknown>, InstanceType<Type<unknown>>>();\r\n\r\n    constructor(\r\n        public readonly name: string | null = null,\r\n    ) {}\r\n\r\n    /**\r\n     * Typically used to create a dependency injection scope\r\n     * at the \"scope\" level (i.e., per-request lifetime).\r\n     *\r\n     * SHOULD NOT BE USED by anything else than the framework itself.\r\n     */\r\n    public createScope(): AppInjector {\r\n        const scope = new AppInjector();\r\n        scope.bindings = this.bindings; // pass injectable declarations\r\n        scope.singletons = this.singletons; // share parent's singletons to avoid recreating them\r\n        // do not keep parent's scoped instances\r\n        return scope;\r\n    }\r\n\r\n    /**\r\n     * Called when resolving a dependency,\r\n     * i.e., retrieving the instance of a given class.\r\n     */\r\n    public resolve<T>(target: Type<T> | ForwardReference<T>): T {\r\n        if (target instanceof ForwardReference) {\r\n            return new Proxy({}, {\r\n                get: (obj, prop, receiver) => {\r\n                    const realType = target.forwardRefFn();\r\n                    const instance = this.resolve(realType) as any;\r\n                    const value = Reflect.get(instance, prop, receiver);\r\n                    \r\n                    return typeof value === 'function' ? value.bind(instance) : value;\r\n                },\r\n                set: (obj, prop, value, receiver) => {\r\n                     const realType = target.forwardRefFn();\r\n                     const instance = this.resolve(realType) as any;\r\n                     return Reflect.set(instance, prop, value, receiver);\r\n                },\r\n                getPrototypeOf: () => {\r\n                     const realType = target.forwardRefFn();\r\n                     return (realType as any).prototype;\r\n                }\r\n            }) as T;\r\n        }\r\n\r\n        const binding = this.bindings.get(target);\r\n\r\n        if(!binding) {\r\n            if(target === undefined) {\r\n                throw new InternalServerException(\r\n                    \"Failed to resolve a dependency injection : Undefined target type.\\n\"\r\n                    + \"This might be caused by a circular dependency.\"\r\n                );\r\n            }\r\n\r\n            const name = target.name || \"unknown\";\r\n\r\n            throw new InternalServerException(\r\n                `Failed to resolve a dependency injection : No binding for type ${name}.\\n`\r\n                + `Did you forget to use @Injectable() decorator ?`\r\n            );\r\n        }\r\n\r\n        switch(binding.lifetime) {\r\n            case 'transient':\r\n                return this.instantiate(binding.implementation) as T;\r\n\r\n            case 'scope': {\r\n                if(this.scoped.has(target)) {\r\n                    return this.scoped.get(target) as T;\r\n                }\r\n\r\n                const instance = this.instantiate(binding.implementation);\r\n                this.scoped.set(target, instance);\r\n\r\n                return instance as T;\r\n            }\r\n\r\n            case 'singleton': {\r\n                if(binding.instance === undefined && this.name === 'root') {\r\n                    binding.instance = this.instantiate(binding.implementation);\r\n                    this.singletons.set(target, binding.instance);\r\n                }\r\n\r\n                return binding.instance as T;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a class, resolving its dependencies.\r\n     */\r\n    private instantiate<T extends Type<unknown>>(target: T): InstanceType<T> {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];\r\n        const injectParams = Reflect.getMetadata(INJECT_METADATA_KEY, target) || [];\r\n\r\n        const params = paramTypes.map((paramType: any, index: number) => {\r\n            const overrideToken = injectParams[index];\r\n            const actualToken = overrideToken !== undefined ? overrideToken : paramType;\r\n\r\n            return this.resolve(actualToken);\r\n        });\r\n\r\n        return new target(...params) as InstanceType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Injects a type from the dependency injection system.\r\n * This function is used to retrieve an instance of a type that has been registered in the dependency injection system.\r\n * It is typically used in the constructor of a class to inject dependencies.\r\n * @param t - The type to inject.\r\n * @returns An instance of the type.\r\n * @throws If the type is not registered in the dependency injection system.\r\n */\r\nexport function inject<T>(t: Type<T> | ForwardReference<T>): T {\r\n    return RootInjector.resolve(t);\r\n}\r\n\r\nexport const RootInjector = new AppInjector('root');\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport 'reflect-metadata';\r\n\r\nexport const INJECT_METADATA_KEY = 'custom:inject';\r\n\r\n/**\r\n * Decorator to manually inject a dependency.\r\n * Useful for handling circular dependencies with `forwardRef` or injecting specific tokens.\r\n *\r\n * @param token The token or forward reference to inject.\r\n */\r\nexport function Inject(token: any): ParameterDecorator {\r\n    return (target, propertyKey, parameterIndex) => {\r\n        // target is the constructor for constructor parameters\r\n        const existingParameters = Reflect.getOwnMetadata(INJECT_METADATA_KEY, target) || [];\r\n        existingParameters[parameterIndex] = token;\r\n        Reflect.defineMetadata(INJECT_METADATA_KEY, existingParameters, target);\r\n    };\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nexport class ResponseException extends Error {\r\n    public readonly status: number = 0;\r\n\r\n    constructor(message?: string);\r\n    constructor(statusCode?: number, message?: string);\r\n    constructor(statusOrMessage?: number | string, message?: string) {\r\n        let statusCode: number | undefined;\r\n        \r\n        if(typeof statusOrMessage === 'number') {\r\n            statusCode = statusOrMessage;\r\n        }\r\n        else if(typeof statusOrMessage === 'string') {\r\n            message = statusOrMessage;\r\n        }\r\n\r\n        super(message ?? \"\");\r\n\r\n        if(statusCode !== undefined) {\r\n            this.status = statusCode;\r\n        }\r\n        \r\n        this.name = this.constructor.name\r\n            .replace(/([A-Z])/g, ' $1');\r\n    }\r\n}\r\n\r\n// 4XX\r\nexport class BadRequestException extends ResponseException { public override readonly status = 400; }\r\nexport class UnauthorizedException extends ResponseException { public override readonly status = 401; }\r\nexport class PaymentRequiredException extends ResponseException { public override readonly status = 402; }\r\nexport class ForbiddenException extends ResponseException { public override readonly status = 403; }\r\nexport class NotFoundException extends ResponseException { public override readonly status = 404; }\r\nexport class MethodNotAllowedException extends ResponseException { public override readonly status = 405; }\r\nexport class NotAcceptableException extends ResponseException { public override readonly status = 406; }\r\nexport class RequestTimeoutException extends ResponseException { public override readonly status = 408; }\r\nexport class ConflictException extends ResponseException { public override readonly status = 409; }\r\nexport class UpgradeRequiredException extends ResponseException { public override readonly status = 426; }\r\nexport class TooManyRequestsException extends ResponseException { public override readonly status = 429; }\r\n// 5XX\r\nexport class InternalServerException extends ResponseException { public override readonly status = 500; }\r\nexport class NotImplementedException extends ResponseException { public override readonly status = 501; }\r\nexport class BadGatewayException extends ResponseException { public override readonly status = 502; }\r\nexport class ServiceUnavailableException extends ResponseException { public override readonly status = 503; }\r\nexport class GatewayTimeoutException extends ResponseException { public override readonly status = 504; }\r\nexport class HttpVersionNotSupportedException extends ResponseException { public override readonly status = 505; }\r\nexport class VariantAlsoNegotiatesException extends ResponseException { public override readonly status = 506; }\r\nexport class InsufficientStorageException extends ResponseException { public override readonly status = 507; }\r\nexport class LoopDetectedException extends ResponseException { public override readonly status = 508; }\r\nexport class NotExtendedException extends ResponseException { public override readonly status = 510; }\r\nexport class NetworkAuthenticationRequiredException extends ResponseException { public override readonly status = 511; }\r\nexport class NetworkConnectTimeoutException extends ResponseException { public override readonly status = 599; }\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { Type } from \"./types\";\r\n\r\n/**\r\n * A function that returns a type.\r\n * Used for forward references to types that are not yet defined.\r\n */\r\nexport interface ForwardRefFn<T = any> {\r\n    (): Type<T>;\r\n}\r\n\r\n/**\r\n * A wrapper class for forward referenced types.\r\n */\r\nexport class ForwardReference<T = any> {\r\n    constructor(public readonly forwardRefFn: ForwardRefFn<T>) {}\r\n}\r\n\r\n/**\r\n * Creates a forward reference to a type.\r\n * @param fn A function that returns the type.\r\n * @returns A ForwardReference instance.\r\n */\r\nexport function forwardRef<T = any>(fn: ForwardRefFn<T>): ForwardReference<T> {\r\n    return new ForwardReference(fn);\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\n/**\r\n * Lightweight event registry to help renderer processes subscribe to\r\n * push messages sent by the main process through Noxus.\r\n */\r\nimport { IRendererEventMessage, isRendererEventMessage } from 'src/request';\r\n\r\nexport type RendererEventHandler<TPayload = unknown> = (payload: TPayload) => void;\r\n\r\nexport interface RendererEventSubscription {\r\n    unsubscribe(): void;\r\n}\r\n\r\nexport class RendererEventRegistry {\r\n    private readonly listeners = new Map<string, Set<RendererEventHandler>>();\r\n\r\n    /**\r\n     *\r\n     */\r\n    public subscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): RendererEventSubscription {\r\n        const normalizedEventName = eventName.trim();\r\n\r\n        if(normalizedEventName.length === 0) {\r\n            throw new Error('Renderer event name must be a non-empty string.');\r\n        }\r\n\r\n        const handlers = this.listeners.get(normalizedEventName) ?? new Set<RendererEventHandler>();\r\n\r\n        handlers.add(handler as RendererEventHandler);\r\n        this.listeners.set(normalizedEventName, handlers);\r\n\r\n        return {\r\n            unsubscribe: () => this.unsubscribe(normalizedEventName, handler as RendererEventHandler),\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public unsubscribe<TPayload>(eventName: string, handler: RendererEventHandler<TPayload>): void {\r\n        const handlers = this.listeners.get(eventName);\r\n\r\n        if(!handlers) {\r\n            return;\r\n        }\r\n\r\n        handlers.delete(handler as RendererEventHandler);\r\n\r\n        if(handlers.size === 0) {\r\n            this.listeners.delete(eventName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public clear(eventName?: string): void {\r\n        if(eventName) {\r\n            this.listeners.delete(eventName);\r\n            return;\r\n        }\r\n\r\n        this.listeners.clear();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public dispatch<TPayload>(message: IRendererEventMessage<TPayload>): void {\r\n        const handlers = this.listeners.get(message.event);\r\n\r\n        if(!handlers || handlers.size === 0) {\r\n            return;\r\n        }\r\n\r\n        handlers.forEach((handler) => {\r\n            try {\r\n                handler(message.payload as TPayload);\r\n            }\r\n            catch(error) {\r\n                console.error(`[Noxus] Renderer event handler for \"${message.event}\" threw an error.`, error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public tryDispatchFromMessageEvent(event: MessageEvent): boolean {\r\n        if(!isRendererEventMessage(event.data)) {\r\n            return false;\r\n        }\r\n\r\n        this.dispatch(event.data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public hasHandlers(eventName: string): boolean {\r\n        const handlers = this.listeners.get(eventName);\r\n        return !!handlers && handlers.size > 0;\r\n    }\r\n}\r\n","/**\r\n * @copyright 2025 NoxFly\r\n * @license MIT\r\n * @author NoxFly\r\n */\r\n\r\nimport { IBatchRequestItem, IBatchResponsePayload, IRequest, IResponse } from 'src/request';\r\nimport { RendererEventRegistry } from 'src/renderer-events';\r\n\r\nexport interface IPortRequester {\r\n    requestPort(): void;\r\n}\r\n\r\nexport interface RendererClientOptions {\r\n    bridge?: IPortRequester | null;\r\n    bridgeName?: string | string[];\r\n    initMessageType?: string;\r\n    windowRef?: Window;\r\n    generateRequestId?: () => string;\r\n}\r\n\r\ninterface PendingRequest<T = unknown> {\r\n    resolve: (value: T) => void;\r\n    reject: (reason: IResponse<T>) => void;\r\n    request: IRequest;\r\n    submittedAt: number;\r\n}\r\n\r\nconst DEFAULT_INIT_EVENT = 'init-port';\r\nconst DEFAULT_BRIDGE_NAMES = ['noxus', 'ipcRenderer'];\r\n\r\nfunction defaultRequestId(): string {\r\n    if(typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\r\n        return crypto.randomUUID();\r\n    }\r\n\r\n    return `${Date.now().toString(16)}-${Math.floor(Math.random() * 1e8).toString(16)}`;\r\n}\r\n\r\nfunction normalizeBridgeNames(preferred?: string | string[]): string[] {\r\n    const names: string[] = [];\r\n\r\n    const add = (name: string | undefined): void => {\r\n        if(!name)\r\n            return;\r\n\r\n        if(!names.includes(name)) {\r\n            names.push(name);\r\n        }\r\n    };\r\n\r\n    if(Array.isArray(preferred)) {\r\n        for(const name of preferred) {\r\n            add(name);\r\n        }\r\n    }\r\n    else {\r\n        add(preferred);\r\n    }\r\n\r\n    for(const fallback of DEFAULT_BRIDGE_NAMES) {\r\n        add(fallback);\r\n    }\r\n\r\n    return names;\r\n}\r\n\r\nfunction resolveBridgeFromWindow(windowRef: Window, preferred?: string | string[]): IPortRequester | null {\r\n    const names = normalizeBridgeNames(preferred);\r\n    const globalRef = windowRef as unknown as Record<string, unknown> | null | undefined;\r\n\r\n    if(!globalRef) {\r\n        return null;\r\n    }\r\n\r\n    for(const name of names) {\r\n        const candidate = globalRef[name];\r\n\r\n        if(candidate && typeof (candidate as IPortRequester).requestPort === 'function') {\r\n            return candidate as IPortRequester;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport class NoxRendererClient {\r\n    public readonly events = new RendererEventRegistry();\r\n\r\n    protected readonly pendingRequests = new Map<string, PendingRequest>();\r\n\r\n    protected requestPort: MessagePort | undefined;\r\n    protected socketPort: MessagePort | undefined;\r\n    protected senderId: number | undefined;\r\n\r\n    private readonly bridge: IPortRequester | null;\r\n    private readonly initMessageType: string;\r\n    private readonly windowRef: Window;\r\n    private readonly generateRequestId: () => string;\r\n\r\n    private isReady = false;\r\n    private setupPromise: Promise<void> | undefined;\r\n    private setupResolve: (() => void) | undefined;\r\n    private setupReject: ((reason: Error) => void) | undefined;\r\n\r\n    constructor(options: RendererClientOptions = {}) {\r\n        this.windowRef = options.windowRef ?? window;\r\n        const resolvedBridge = options.bridge ?? resolveBridgeFromWindow(this.windowRef, options.bridgeName);\r\n        this.bridge = resolvedBridge ?? null;\r\n        this.initMessageType = options.initMessageType ?? DEFAULT_INIT_EVENT;\r\n        this.generateRequestId = options.generateRequestId ?? defaultRequestId;\r\n    }\r\n\r\n    public async setup(): Promise<void> {\r\n        if(this.isReady) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if(this.setupPromise) {\r\n            return this.setupPromise;\r\n        }\r\n\r\n        if(!this.bridge || typeof this.bridge.requestPort !== 'function') {\r\n            throw new Error('[Noxus] Renderer bridge is missing requestPort().');\r\n        }\r\n\r\n        this.setupPromise = new Promise<void>((resolve, reject) => {\r\n            this.setupResolve = resolve;\r\n            this.setupReject = reject;\r\n        });\r\n\r\n        this.windowRef.addEventListener('message', this.onWindowMessage);\r\n        this.bridge.requestPort();\r\n\r\n        return this.setupPromise;\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort?.close();\r\n        this.socketPort?.close();\r\n\r\n        this.requestPort = undefined;\r\n        this.socketPort = undefined;\r\n        this.senderId = undefined;\r\n        this.isReady = false;\r\n\r\n        this.pendingRequests.clear();\r\n    }\r\n\r\n    public async request<TResponse, TBody = unknown>(request: Omit<IRequest<TBody>, 'requestId' | 'senderId'>): Promise<TResponse> {\r\n        const senderId = this.senderId;\r\n        const requestId = this.generateRequestId();\r\n\r\n        if(senderId === undefined) {\r\n            return Promise.reject(this.createErrorResponse(requestId, 'MessagePort is not available'));\r\n        }\r\n\r\n        const readinessError = this.validateReady(requestId);\r\n\r\n        if(readinessError) {\r\n            return Promise.reject(readinessError as IResponse<TResponse>);\r\n        }\r\n\r\n        const message: IRequest<TBody> = {\r\n            requestId,\r\n            senderId,\r\n            ...request,\r\n        };\r\n\r\n        return new Promise<TResponse>((resolve, reject) => {\r\n            const pending: PendingRequest<TResponse> = {\r\n                resolve,\r\n                reject: (response: IResponse<TResponse>) => reject(response),\r\n                request: message,\r\n                submittedAt: Date.now(),\r\n            };\r\n\r\n            this.pendingRequests.set(message.requestId, pending as PendingRequest);\r\n\r\n            this.requestPort!.postMessage(message);\r\n        });\r\n    }\r\n\r\n    public async batch(requests: Omit<IBatchRequestItem<unknown>, 'requestId'>[]): Promise<IBatchResponsePayload> {\r\n        return this.request<IBatchResponsePayload>({\r\n            method: 'BATCH',\r\n            path: '',\r\n            body: {\r\n                requests,\r\n            },\r\n        });\r\n    }\r\n\r\n    public getSenderId(): number | undefined {\r\n        return this.senderId;\r\n    }\r\n\r\n    private readonly onWindowMessage = (event: MessageEvent): void => {\r\n        if(event.data?.type !== this.initMessageType) {\r\n            return;\r\n        }\r\n\r\n        if(!Array.isArray(event.ports) || event.ports.length < 2) {\r\n            const error = new Error('[Noxus] Renderer expected two MessagePorts (request + socket).');\r\n\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.windowRef.removeEventListener('message', this.onWindowMessage);\r\n\r\n        this.requestPort = event.ports[0];\r\n        this.socketPort = event.ports[1];\r\n        this.senderId = event.data.senderId;\r\n\r\n        if(this.requestPort === undefined || this.socketPort === undefined) {\r\n            const error = new Error('[Noxus] Renderer failed to receive valid MessagePorts.');\r\n            console.error(error);\r\n            this.setupReject?.(error);\r\n            this.resetSetupState();\r\n            return;\r\n        }\r\n\r\n        this.attachRequestPort(this.requestPort);\r\n        this.attachSocketPort(this.socketPort);\r\n\r\n        this.isReady = true;\r\n        this.setupResolve?.();\r\n        this.resetSetupState(true);\r\n    };\r\n\r\n    private readonly onSocketMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        console.warn('[Noxus] Received a socket message that is not a renderer event payload.', event.data);\r\n    };\r\n\r\n    private readonly onRequestMessage = (event: MessageEvent): void => {\r\n        if(this.events.tryDispatchFromMessageEvent(event)) {\r\n            return;\r\n        }\r\n\r\n        const response: IResponse = event.data;\r\n\r\n        if(!response || typeof response.requestId !== 'string') {\r\n            console.error('[Noxus] Renderer received an invalid response payload.', response);\r\n            return;\r\n        }\r\n\r\n        const pending = this.pendingRequests.get(response.requestId);\r\n\r\n        if(!pending) {\r\n            console.error(`[Noxus] No pending handler found for request ${response.requestId}.`);\r\n            return;\r\n        }\r\n\r\n        this.pendingRequests.delete(response.requestId);\r\n\r\n        this.onRequestCompleted(pending, response);\r\n\r\n        if(response.status >= 400) {\r\n            pending.reject(response as IResponse<any>);\r\n            return;\r\n        }\r\n\r\n        pending.resolve(response.body as unknown);\r\n    };\r\n\r\n    protected onRequestCompleted(pending: PendingRequest, response: IResponse): void {\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupCollapsed(`${response.status} ${pending.request.method} /${pending.request.path}`);\r\n        }\r\n\r\n        if(response.error) {\r\n            console.error('error message:', response.error);\r\n        }\r\n\r\n        if(response.body !== undefined) {\r\n            console.info('response:', response.body);\r\n        }\r\n\r\n        console.info('request:', pending.request);\r\n        console.info(`Request duration: ${Date.now() - pending.submittedAt} ms`);\r\n\r\n        if(typeof console.groupCollapsed === 'function') {\r\n            console.groupEnd();\r\n        }\r\n    }\r\n\r\n    private attachRequestPort(port: MessagePort): void {\r\n        port.onmessage = this.onRequestMessage;\r\n        port.start();\r\n    }\r\n\r\n    private attachSocketPort(port: MessagePort): void {\r\n        port.onmessage = this.onSocketMessage;\r\n        port.start();\r\n    }\r\n\r\n    private validateReady(requestId: string): IResponse | undefined {\r\n        if(!this.isElectronEnvironment()) {\r\n            return this.createErrorResponse(requestId, 'Not running in Electron environment');\r\n        }\r\n\r\n        if(!this.requestPort) {\r\n            return this.createErrorResponse(requestId, 'MessagePort is not available');\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private createErrorResponse<T>(requestId: string, message: string): IResponse<T> {\r\n        return {\r\n            status: 500,\r\n            requestId,\r\n            error: message,\r\n        };\r\n    }\r\n\r\n    private resetSetupState(success = false): void {\r\n        if(!success) {\r\n            this.setupPromise = undefined;\r\n        }\r\n\r\n        this.setupResolve = undefined;\r\n        this.setupReject = undefined;\r\n    }\r\n\r\n    public isElectronEnvironment(): boolean {\r\n        return typeof window !== 'undefined' && /Electron/.test(window.navigator.userAgent);\r\n    }\r\n}\r\n"],"mappings":"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","names":["INJECT_METADATA_KEY","ResponseException","Error","statusOrMessage","message","statusCode","status","undefined","name","replace","InternalServerException","ResponseException","status","ForwardReference","forwardRefFn","AppInjector","name","bindings","Map","singletons","scoped","createScope","scope","resolve","target","ForwardReference","Proxy","get","obj","prop","receiver","realType","forwardRefFn","instance","value","Reflect","bind","set","getPrototypeOf","prototype","binding","undefined","InternalServerException","lifetime","instantiate","implementation","has","paramTypes","getMetadata","injectParams","INJECT_METADATA_KEY","params","map","paramType","index","overrideToken","actualToken","RootInjector","AppInjector","Request","event","senderId","id","method","path","body","context","RootInjector","createScope","params","replace","RENDERER_EVENT_TYPE","createRendererEventMessage","payload","type","isRendererEventMessage","value","possibleMessage","RendererEventRegistry","listeners","Map","subscribe","eventName","handler","normalizedEventName","trim","length","Error","handlers","get","Set","add","set","unsubscribe","delete","size","clear","dispatch","message","event","forEach","payload","error","console","tryDispatchFromMessageEvent","isRendererEventMessage","data","hasHandlers","DEFAULT_INIT_EVENT","DEFAULT_BRIDGE_NAMES","defaultRequestId","crypto","randomUUID","Date","now","toString","Math","floor","random","normalizeBridgeNames","preferred","names","add","name","includes","push","Array","isArray","fallback","resolveBridgeFromWindow","windowRef","globalRef","candidate","requestPort","NoxRendererClient","options","events","RendererEventRegistry","pendingRequests","Map","socketPort","senderId","bridge","initMessageType","generateRequestId","isReady","setupPromise","setupResolve","setupReject","onWindowMessage","event","data","type","ports","length","error","Error","console","resetSetupState","removeEventListener","undefined","attachRequestPort","attachSocketPort","onSocketMessage","tryDispatchFromMessageEvent","warn","onRequestMessage","response","requestId","pending","get","delete","onRequestCompleted","status","reject","resolve","body","window","resolvedBridge","bridgeName","setup","Promise","addEventListener","dispose","close","clear","request","createErrorResponse","readinessError","validateReady","message","submittedAt","set","postMessage","batch","requests","method","path","getSenderId","groupCollapsed","info","groupEnd","port","onmessage","start","isElectronEnvironment","success","test","navigator","userAgent"]}